# How it works

This file will be extended and translated before merge.

## IEntrypoint

На каждый файл создаётся `IEntrypoint` (неудачное название, так как он оказался нужен не только на entry), содержащий:
* `name` с полным именем файла;
* `only` со списком экспортов, который из этого файла нужны;
* `idx`, выдаваемый последовательно для каждого имени файла;
* `generation` — номер поколения (увеличивается, если этот энтрипоинт пересоздавался с новым набором `only`);
* `log`'ер, привязанный к этому энтрипоинту;
* `parent` со ссылкой на родителя или null, если это корень дерева;
* `code` с кодом файла;
* `ast` с деревом из `code`;
* `evalConfig` babel-конфиг с которым этот файл надо будет подготовить к запуску;
* `evaluator`-функция для подготовки к запуску (тоже название неудачное);
* `pluginOptions` опции Линарии.

### createEntrypoint

Создание `IEntrypoint` происходит строго внутри функции `createEntrypoint`. Если функция вызывается несколько раз для одного и того же файла, то:
* если был передан код файла и он отличается от того, что в кэше (например, HMR или когда первый раз мы прочитали код из файла, а на второй он прилетел из лоадера уже трансформированный), сбрасываем все связанные с этим файлом кэши и дальше действуем будто это первый вызов для файла;
* если вызван с тем же или более узким `only`, то вместо создания нового возвращаем созданный ранее;
* если новый `only` более широкий чем закэшированный, то создаём новое поколение IEntrypoint и уведомляем все заинтересованные стороны о том, что произошло замещение (`onSupersede`);
* если при создании выясняется, что в цепочке `parent`'ов уже есть этот файл, то вместо возвращаения нового `IEntrypoint` возвращаем `"ignored"` и для родителя вызывается `onSupersede`.

Замещение означает, что задачи, запущенные для старого `IEntrypoint`, резко становятся неактуальными и их надо прибить и запустить процессинг для него с нуля. Если часть задач уже успела выполниться и в очередь поставятся их копии (например, новый энтрипоинт не изменил список импортов и `resolveImports` поставится с тем же набором аргументов), то исполнение таких задач пропустится и результат будет забран из кэша. При этом, результатом работы задачи считается не только возвращаемое значение, но и выкинутые ей в очередь сабтаски, которые так же будут выкинуты в очередь. Закидывать сабтаски ранее выполненной таски в очередь надо на тот случай, если какие-то из них были абортнуты из-за supersede.

Каждый созданный или пересозданный `IEntrypoint` закидывается в очередь с задачей `processEntrypoint`. Замещение не привязано к конкретному экземпляру очереди и если в очередь `A` добавился `IEntrypoint[foo]`, а потом в `B` добавился `IEntrypoint[foo,bar]`, то для `IEntrypoint[foo]` в очереди `A` будет вызван `onSupersede`, все привязанные к оригиналу действия из `A` будут удалены и добавлено новое `processEntrypoint(IEntrypoint[foo,bar])`.

## Actions


### processEntrypoint

Заводит `AbortController`, подписывается на `AbortSignal` родителя (если есть), подписывается на `onSupersede` и закидывает в очередь три новых таски: `explodeReexports`, `transform` и `finalizeEntrypoint`. В первые две таски передаётся `AbortSignal`, который будет вызван в случае замещения `IEntrypoint`, а `finalizeEntrypoint` должен вызываться в любом случае в самом конце обработки дерева задач этого энтрипоинта. Если у экшена указан `AbortSignal`, то по умолчанию он наследуется всеми порождаемыми действиями.

### explodeReexports

Находит инструкции `export * from 'file-name'`, складывает для каждой из них в очередь `getExports`, а по исполнению `getExports` заменяет `*` на именованный список.


### getExports

Находит имена всех экспортов в файле, а если в файле есть `export * from`, то рекурсивно добавляет себя в очередь для каждой такой инструкции, пока не получится развернуть весь список.


### transform

Готовит файл к исполнению: находит используемые linaria-процессоры, вызывает eval-time замены для них, удаляет лишний код, вызывает `evaluator`. Из оставшегося кода достаются уцелевшие импорты, оборачиваются в `resolveImports` и складываются в очередь. После резолва импортов, ставится задача `processImports` на их обработку. Финальным действием идёт `addToCodeCache`, которое складывает всю полученную информацию в кэш для дальнейшего использования в `module.ts`.


### resolveImports

Существует в двух вариантах: синхронном для строго синхронных окружений и асинхронном на случаи, если функция-резолвер файлов поставляется исключительно в асинхронном варианте (то есть всегда). Оба варианта делают одно и то же, с поправкой на синхронность и асинхронность: вызывают переданную функцию-резовлер для каждого указанного импорта, а так же кэшируют результаты. Асинхронная версия кроме результатов кэширует ещё и промис, чтобы гарантировать, что не будет запущено две параллельных таски на резолв, и обеспечить строгую очередь «первый спросил — первому ответили».


### processImports

Вызывает `createEntrypoint` для каждого импорта. На данном этапе может вернуться `"ignored"`, если мы попали в петлю. В этом случае конкретный импорт пропускается. Для остальных же в очередь будут добавлены `processEntrypoint` без `AbortSignal` родителя (в этом месте я не уверен, нужно ли пробрасывать сигнал глубже и канцелять их вместе с корневым `IEntrypoint` или нехай живут).


### addToCodeCache

Просто добавляет результат кэш. Можно было бы делать это непосредственно в `transform`, но так в логах нагляднее.


### finalizeEntrypoint

Должен вызываться для освобождения ресурсов, когда всё под-дерево обработки конкретного файла было завершено. Но по факту вызывается в самом конце вообще, так как механизм приоритизации хромает на обе ноги.
