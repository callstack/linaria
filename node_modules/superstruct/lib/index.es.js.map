{"version":3,"file":"index.es.js","sources":["../src/error.ts","../src/utils.ts","../src/structs/utilities.ts","../src/structs/types.ts","../src/structs/coercions.ts","../src/struct.ts","../src/structs/refinements.ts"],"sourcesContent":["/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\nexport type Failure = {\n  value: any\n  key: string | number | undefined\n  type: string\n  refinement: string | undefined\n  message: string\n  branch: Array<any>\n  path: Array<string | number>\n}\n\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\n\nexport class StructError extends TypeError {\n  value: any\n  key!: string | number | undefined\n  type!: string\n  refinement!: string | undefined\n  path!: Array<number | string>\n  branch!: Array<any>\n  failures: () => Array<Failure>;\n  [x: string]: any\n\n  constructor(failure: Failure, moreFailures: IterableIterator<Failure>) {\n    const { message, ...rest } = failure\n    const { path } = failure\n    let failures: Array<Failure> | undefined\n    const msg =\n      path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`\n    super(msg)\n    Object.assign(this, rest)\n    this.name = this.constructor.name\n    this.failures = (): Array<Failure> => {\n      if (!failures) {\n        failures = [failure, ...moreFailures]\n      }\n\n      return failures\n    }\n  }\n}\n","import { Struct, Infer, Result, Context, Describe } from './struct'\nimport { Failure } from './error'\n\n/**\n * Check if a value is a plain object.\n */\n\nexport function isPlainObject(value: unknown): value is { [key: string]: any } {\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(value)\n  return prototype === null || prototype === Object.prototype\n}\n\n/**\n * Return a value as a printable string.\n */\n\nexport function print(value: any): string {\n  return typeof value === 'string' ? JSON.stringify(value) : `${value}`\n}\n\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\nexport function shiftIterator<T>(input: Iterator<T>): T | undefined {\n  const { done, value } = input.next()\n  return done ? undefined : value\n}\n\n/**\n * Convert a validation result to an iterable of failures.\n */\n\nexport function* toFailures<T, S>(\n  result: Result,\n  context: Context<T, S>\n): IterableIterator<Failure> {\n  if (typeof result === 'string') {\n    yield context.fail({ message: result })\n  } else if (result === true) {\n    return\n  } else if (result === false) {\n    yield context.fail()\n  } else {\n    yield* result\n  }\n}\n\n/**\n * Check if a type is a tuple.\n */\n\nexport type IsTuple<T> = T extends [any]\n  ? T\n  : T extends [any, any]\n  ? T\n  : T extends [any, any, any]\n  ? T\n  : T extends [any, any, any, any]\n  ? T\n  : T extends [any, any, any, any, any]\n  ? T\n  : never\n\n/**\n * Check if a type is a record type.\n */\n\nexport type IsRecord<T> = T extends object\n  ? string extends keyof T\n    ? T\n    : never\n  : never\n\n/**\n * Check if a type is a generic string type.\n */\n\nexport type IsGenericString<T> = T extends string\n  ? string extends T\n    ? T\n    : never\n  : never\n\n/**\n * Normalize properties of a type that allow `undefined` to make them optional.\n */\n\nexport type Optionalize<S extends object> = OmitBy<S, undefined> &\n  Partial<PickBy<S, undefined>>\n\n/**\n * Omit properties from a type that extend from a specific type.\n */\n\nexport type OmitBy<T, V> = Omit<\n  T,\n  { [K in keyof T]: V extends Extract<T[K], V> ? K : never }[keyof T]\n>\n\n/**\n * Pick properties from a type that extend from a specific type.\n */\n\nexport type PickBy<T, V> = Pick<\n  T,\n  { [K in keyof T]: V extends Extract<T[K], V> ? K : never }[keyof T]\n>\n\n/**\n * Simplifies a type definition to its most basic representation.\n */\n\nexport type Simplify<T> = T extends any[] | Date\n  ? T\n  : { [K in keyof T]: T[K] } & {}\n\n/**\n * Assign properties from one type to another, overwriting existing.\n */\n\nexport type Assign<T, U> = Simplify<U & Omit<T, keyof U>>\n\n/**\n * A schema for object structs.\n */\n\nexport type ObjectSchema = Record<string, Struct<any, any>>\n\n/**\n * Infer a type from an object struct schema.\n */\n\nexport type ObjectType<S extends ObjectSchema> = Simplify<\n  Optionalize<{ [K in keyof S]: Infer<S[K]> }>\n>\n\n/**\n * Transform an object schema type to represent a partial.\n */\n\nexport type PartialObjectSchema<S extends ObjectSchema> = {\n  [K in keyof S]: Struct<Infer<S[K]> | undefined>\n}\n\n/**\n * A schema for any type of struct.\n */\n\nexport type StructSchema<T> = [T] extends [string]\n  ? [T] extends [IsGenericString<T>]\n    ? null\n    : EnumSchema<T>\n  : T extends\n      | number\n      | boolean\n      | bigint\n      | symbol\n      | undefined\n      | null\n      | Function\n      | Date\n      | Error\n      | RegExp\n  ? null\n  : T extends Map<any, any>\n  ? null\n  : T extends WeakMap<any, any>\n  ? null\n  : T extends Set<any>\n  ? null\n  : T extends WeakSet<any>\n  ? null\n  : T extends Array<infer E>\n  ? T extends IsTuple<T>\n    ? null\n    : Struct<E>\n  : T extends Promise<any>\n  ? null\n  : T extends object\n  ? T extends IsRecord<T>\n    ? null\n    : { [K in keyof T]: Describe<T[K]> }\n  : null\n\n/**\n * A schema for enum structs.\n */\n\nexport type EnumSchema<T extends string> = { [K in T]: K }\n\n/**\n * A schema for tuple structs.\n */\n\nexport type TupleSchema<T> = { [K in keyof T]: Struct<T[K]> }\n","import { Struct, Context, Validator } from '../struct'\nimport { object, optional } from './types'\nimport { ObjectSchema, Assign, ObjectType, PartialObjectSchema } from '../utils'\n\n/**\n * Create a new struct that combines the properties properties from multiple\n * object structs.\n *\n * Like JavaScript's `Object.assign` utility.\n */\n\nexport function assign<A extends ObjectSchema, B extends ObjectSchema>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>\n): Struct<ObjectType<Assign<A, B>>, Assign<A, B>>\nexport function assign<\n  A extends ObjectSchema,\n  B extends ObjectSchema,\n  C extends ObjectSchema\n>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>,\n  C: Struct<ObjectType<C>, C>\n): Struct<ObjectType<Assign<Assign<A, B>, C>>, Assign<Assign<A, B>, C>>\nexport function assign<\n  A extends ObjectSchema,\n  B extends ObjectSchema,\n  C extends ObjectSchema,\n  D extends ObjectSchema\n>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>,\n  C: Struct<ObjectType<C>, C>,\n  D: Struct<ObjectType<D>, D>\n): Struct<\n  ObjectType<Assign<Assign<Assign<A, B>, C>, D>>,\n  Assign<Assign<Assign<A, B>, C>, D>\n>\nexport function assign<\n  A extends ObjectSchema,\n  B extends ObjectSchema,\n  C extends ObjectSchema,\n  D extends ObjectSchema,\n  E extends ObjectSchema\n>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>,\n  C: Struct<ObjectType<C>, C>,\n  D: Struct<ObjectType<D>, D>,\n  E: Struct<ObjectType<E>, E>\n): Struct<\n  ObjectType<Assign<Assign<Assign<Assign<A, B>, C>, D>, E>>,\n  Assign<Assign<Assign<Assign<A, B>, C>, D>, E>\n>\nexport function assign(...Structs: Struct<any>[]): any {\n  const schemas = Structs.map((s) => s.schema)\n  const schema = Object.assign({}, ...schemas)\n  return object(schema)\n}\n\n/**\n * Define a new struct type with a custom validation function.\n */\n\nexport function define<T>(\n  name: string,\n  validator: Validator<T, null>\n): Struct<T, null> {\n  return new Struct({ type: name, schema: null, validator })\n}\n\n/**\n * Create a struct with dynamic, runtime validation.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\n\nexport function dynamic<T>(\n  fn: (value: unknown, ctx: Context<T, null>) => Struct<T, any>\n): Struct<T, null> {\n  return define('dynamic', (value, ctx) => {\n    return ctx.check(value, fn(value, ctx))\n  })\n}\n\n/**\n * Create a struct with lazily evaluated validation.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\n\nexport function lazy<T>(fn: () => Struct<T, any>): Struct<T, null> {\n  let s: Struct<T, any> | undefined\n\n  return define('lazy', (value, ctx) => {\n    if (!s) {\n      s = fn()\n    }\n\n    return ctx.check(value, s)\n  })\n}\n\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\n\nexport function omit<S extends ObjectSchema, K extends keyof S>(\n  struct: Struct<ObjectType<S>, S>,\n  keys: K[]\n): Struct<ObjectType<Omit<S, K>>, Omit<S, K>> {\n  const { schema } = struct\n  const subschema: any = { ...schema }\n\n  for (const key of keys) {\n    delete subschema[key]\n  }\n\n  return object(subschema as Omit<S, K>)\n}\n\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\n\nexport function partial<S extends ObjectSchema>(\n  struct: Struct<ObjectType<S>, S> | S\n): Struct<ObjectType<PartialObjectSchema<S>>, PartialObjectSchema<S>> {\n  const schema: any =\n    struct instanceof Struct ? { ...struct.schema } : { ...struct }\n\n  for (const key in schema) {\n    schema[key] = optional(schema[key])\n  }\n\n  return object(schema) as any\n}\n\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\n\nexport function pick<S extends ObjectSchema, K extends keyof S>(\n  struct: Struct<ObjectType<S>, S>,\n  keys: K[]\n): Struct<ObjectType<Pick<S, K>>, Pick<S, K>> {\n  const { schema } = struct\n  const subschema: any = {}\n\n  for (const key of keys) {\n    subschema[key] = schema[key]\n  }\n\n  return object(subschema as Pick<S, K>)\n}\n\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\n\nexport function struct<T>(\n  name: string,\n  validator: Validator<T, null>\n): Struct<T, null> {\n  console.warn(\n    'superstruct@0.11 - The `struct` helper has been renamed to `define`.'\n  )\n\n  return define(name, validator)\n}\n","import { Infer, Struct } from '../struct'\nimport { define } from './utilities'\nimport {\n  TupleSchema,\n  ObjectSchema,\n  ObjectType,\n  toFailures,\n  print,\n} from '../utils'\n\n/**\n * Ensure that any value passes validation.\n */\n\nexport function any(): Struct<any, null> {\n  return define('any', () => true)\n}\n\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n */\n\nexport function array<T extends Struct<any>>(Element: T): Struct<Infer<T>[], T>\nexport function array(): Struct<unknown[], undefined>\nexport function array<T extends Struct<any>>(Element?: T): any {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n    coercer: (value) => {\n      return Element && Array.isArray(value)\n        ? value.map((v) => Element.coercer(v))\n        : value\n    },\n    *validator(value, ctx) {\n      if (!Array.isArray(value)) {\n        yield ctx.fail(`Expected an array value, but received: ${print(value)}`)\n      } else if (Element) {\n        for (const [i, v] of value.entries()) {\n          yield* ctx.check(v, Element, value, i)\n        }\n      }\n    },\n  })\n}\n\n/**\n * Ensure that a value is a boolean.\n */\n\nexport function boolean(): Struct<boolean, null> {\n  return define('boolean', (value) => {\n    return typeof value === 'boolean'\n  })\n}\n\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\nexport function date(): Struct<Date, null> {\n  return define('date', (value) => {\n    return (\n      (value instanceof Date && !isNaN(value.getTime())) ||\n      `Expected a valid \\`Date\\` object, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n */\n\nexport function enums<T extends number>(\n  values: readonly T[]\n): Struct<T, { [K in T[][number]]: K }>\nexport function enums<T extends string>(\n  values: readonly T[]\n): Struct<T, { [K in T[][number]]: K }>\nexport function enums<T extends number | string>(values: readonly T[]): any {\n  const schema: any = {}\n  const description = values.map((v) => print(v)).join()\n\n  for (const key of values) {\n    schema[key] = key\n  }\n\n  return new Struct({\n    type: 'enums',\n    schema,\n    validator: (value) => {\n      return (\n        values.includes(value as any) ||\n        `Expected one of \\`${description}\\`, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a function.\n */\n\nexport function func(): Struct<Function, null> {\n  return define('func', (value) => {\n    return (\n      typeof value === 'function' ||\n      `Expected a function, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is an instance of a specific class.\n */\n\nexport function instance<T extends { new (...args: any): any }>(\n  Class: T\n): Struct<InstanceType<T>, null> {\n  return define('instance', (value) => {\n    return (\n      value instanceof Class ||\n      `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is an integer.\n */\n\nexport function integer(): Struct<number, null> {\n  return define('integer', (value) => {\n    return (\n      (typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n      `Expected an integer, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value matches all of a set of types.\n */\n\nexport function intersection<A>(Structs: TupleSchema<[A]>): Struct<A, null>\nexport function intersection<A, B>(\n  Structs: TupleSchema<[A, B]>\n): Struct<A & B, null>\nexport function intersection<A, B, C>(\n  Structs: TupleSchema<[A, B, C]>\n): Struct<A & B & C, null>\nexport function intersection<A, B, C, D>(\n  Structs: TupleSchema<[A, B, C, D]>\n): Struct<A & B & C & D, null>\nexport function intersection<A, B, C, D, E>(\n  Structs: TupleSchema<[A, B, C, D, E]>\n): Struct<A & B & C & D & E, null>\nexport function intersection<A, B, C, D, E, F>(\n  Structs: TupleSchema<[A, B, C, D, E, F]>\n): Struct<A & B & C & D & E & F, null>\nexport function intersection<A, B, C, D, E, F, G>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G]>\n): Struct<A & B & C & D & E & F & G, null>\nexport function intersection<A, B, C, D, E, F, G, H>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H]>\n): Struct<A & B & C & D & E & F & G & H, null>\nexport function intersection<A, B, C, D, E, F, G, H, I>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I]>\n): Struct<A & B & C & D & E & F & G & H & I, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J]>\n): Struct<A & B & C & D & E & F & G & H & I & J, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N & O, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N & O & P, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\n): Struct<\n  A & B & C & D & E & F & G & H & I & J & K & L & M & N & O & P & Q,\n  null\n>\nexport function intersection(Structs: Array<Struct<any, any>>): any {\n  return define('intersection', function* (value, ctx) {\n    for (const S of Structs) {\n      yield* ctx.check(value, S)\n    }\n  })\n}\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n */\n\nexport function literal<T extends boolean>(constant: T): Struct<T, null>\nexport function literal<T extends number>(constant: T): Struct<T, null>\nexport function literal<T extends string>(constant: T): Struct<T, null>\nexport function literal<T>(constant: T): Struct<T, null>\nexport function literal<T>(constant: T): any {\n  const description = print(constant)\n  return define('literal', (value) => {\n    return (\n      value === constant ||\n      `Expected the literal \\`${description}\\`, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n */\n\nexport function map(): Struct<Map<unknown, unknown>, null>\nexport function map<K, V>(\n  Key: Struct<K>,\n  Value: Struct<V>\n): Struct<Map<K, V>, null>\nexport function map<K, V>(Key?: Struct<K>, Value?: Struct<V>): any {\n  return define('map', function* (value, ctx) {\n    if (!(value instanceof Map)) {\n      yield ctx.fail(`Expected a \\`Map\\` object, but received: ${print(value)}`)\n    } else if (Key && Value) {\n      for (const [k, v] of value.entries()) {\n        yield* ctx.check(k, Key, value, k)\n        yield* ctx.check(v, Value, value, k)\n      }\n    }\n  })\n}\n\n/**\n * Ensure that no value ever passes validation.\n */\n\nexport function never(): Struct<never, null> {\n  return define('never', () => false)\n}\n\n/**\n * Augment an existing struct to allow `null` values.\n */\n\nexport function nullable<T, S>(struct: Struct<T, S>): Struct<T | null, S> {\n  const { refiner } = struct\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) => {\n      return value === null || ctx.check(value, struct)\n    },\n    refiner: function* (value, ctx) {\n      if (value != null) {\n        const c = { ...ctx, struct }\n        yield* toFailures(refiner(value, c), c)\n      }\n    },\n  })\n}\n\n/**\n * Ensure that a value is a number.\n */\n\nexport function number(): Struct<number, null> {\n  return define('number', (value) => {\n    return (\n      (typeof value === 'number' && !isNaN(value)) ||\n      `Expected a number, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is an object, that is has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n */\n\nexport function object(): Struct<Record<string, unknown>, null>\nexport function object<S extends ObjectSchema>(\n  schema: S\n): Struct<ObjectType<S>, S>\nexport function object<S extends ObjectSchema>(schema?: S): any {\n  const knowns = schema ? Object.keys(schema) : []\n  const Never = never()\n  return new Struct({\n    type: 'object',\n    schema: schema ? schema : null,\n    *validator(value, ctx) {\n      if (typeof value !== 'object' || value == null) {\n        yield ctx.fail(`Expected an object, but received: ${print(value)}`)\n      } else if (schema) {\n        const unknowns = new Set(Object.keys(value))\n\n        for (const key of knowns) {\n          unknowns.delete(key)\n          const Value = schema[key]\n          const v = value[key]\n          yield* ctx.check(v, Value, value, key)\n        }\n\n        for (const key of unknowns) {\n          const v = value[key]\n          yield* ctx.check(v, Never, value, key)\n        }\n      }\n    },\n    coercer: (value: unknown) => {\n      if (!schema || typeof value !== 'object' || value == null) {\n        return value\n      }\n\n      const ret = {}\n      const unknowns = new Set(Object.keys(value))\n\n      for (const key of knowns) {\n        unknowns.delete(key)\n        const Value = schema[key]\n        const v = value[key]\n        ret[key] = Value.coercer(v)\n      }\n\n      for (const key of unknowns) {\n        ret[key] = value[key]\n      }\n\n      return ret\n    },\n  })\n}\n\n/**\n * Augment a struct to allow `undefined` values.\n */\n\nexport function optional<T, S>(struct: Struct<T, S>): Struct<T | undefined, S> {\n  const { refiner } = struct\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) => {\n      return value === undefined || ctx.check(value, struct)\n    },\n    refiner: function* (value, ctx) {\n      if (value != null) {\n        const c = { ...ctx, struct }\n        yield* toFailures(refiner(value, c), c)\n      }\n    },\n  })\n}\n\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n\nexport function record<K extends string, V>(\n  Key: Struct<K>,\n  Value: Struct<V>\n): Struct<Record<K, V>, null> {\n  return define('record', function* (value, ctx) {\n    if (typeof value !== 'object' || value == null) {\n      yield ctx.fail(`Expected an object, but received: ${print(value)}`)\n    } else {\n      for (const k in value) {\n        const v = value[k]\n        yield* ctx.check(k, Key, value, k)\n        yield* ctx.check(v, Value, value, k)\n      }\n    }\n  })\n}\n\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\n\nexport function regexp(): Struct<RegExp, null> {\n  return define('regexp', (value) => {\n    return value instanceof RegExp\n  })\n}\n\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n */\n\nexport function set(): Struct<Set<unknown>, null>\nexport function set<T>(Element: Struct<T>): Struct<Set<T>, null>\nexport function set<T>(Element?: Struct<T>): any {\n  return define('set', function* (value, ctx) {\n    if (!(value instanceof Set)) {\n      yield ctx.fail(`Expected a \\`Set\\` object, but received: ${print(value)}`)\n    } else if (Element) {\n      for (const val of value) {\n        yield* ctx.check(val, Element, value, val)\n      }\n    }\n  })\n}\n\n/**\n * Ensure that a value is a string.\n */\n\nexport function string(): Struct<string, null> {\n  return define('string', (value) => {\n    return (\n      typeof value === 'string' ||\n      `Expected a string, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\n\nexport function tuple<A>(Structs: TupleSchema<[A]>): Struct<[A], null>\nexport function tuple<A, B>(Structs: TupleSchema<[A, B]>): Struct<[A, B], null>\nexport function tuple<A, B, C>(\n  Structs: TupleSchema<[A, B, C]>\n): Struct<[A, B, C], null>\nexport function tuple<A, B, C, D>(\n  Structs: TupleSchema<[A, B, C, D]>\n): Struct<[A, B, C, D], null>\nexport function tuple<A, B, C, D, E>(\n  Structs: TupleSchema<[A, B, C, D, E]>\n): Struct<[A, B, C, D, E], null>\nexport function tuple<A, B, C, D, E, F>(\n  Structs: TupleSchema<[A, B, C, D, E, F]>\n): Struct<[A, B, C, D, E, F], null>\nexport function tuple<A, B, C, D, E, F, G>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G]>\n): Struct<[A, B, C, D, E, F, G], null>\nexport function tuple<A, B, C, D, E, F, G, H>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H]>\n): Struct<[A, B, C, D, E, F, G, H], null>\nexport function tuple<A, B, C, D, E, F, G, H, I>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I]>\n): Struct<[A, B, C, D, E, F, G, H, I], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J]>\n): Struct<[A, B, C, D, E, F, G, H, I, J], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q], null>\nexport function tuple(Elements: Struct<any>[]): any {\n  const Never = never()\n\n  return define('tuple', function* (value, ctx) {\n    if (!Array.isArray(value)) {\n      yield ctx.fail(`Expected an array, but received: ${print(value)}`)\n    } else {\n      for (const [index, Element] of Elements.entries()) {\n        const v = value[index]\n        yield* ctx.check(v, Element, value, index)\n      }\n\n      if (value.length > Elements.length) {\n        const index = Elements.length\n        const v = value[index]\n        yield* ctx.check(v, Never, value, index)\n      }\n    }\n  })\n}\n\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\n\nexport function type<S extends ObjectSchema>(\n  schema: S\n): Struct<ObjectType<S>, S> {\n  const keys = Object.keys(schema)\n  return new Struct({\n    type: 'type',\n    schema,\n    validator: function* (value, ctx) {\n      if (typeof value !== 'object' || value == null) {\n        yield ctx.fail(`Expected an object, but received: ${print(value)}`)\n      } else {\n        for (const key of keys) {\n          const Value = schema[key]\n          const v = (value as any)[key]\n          yield* ctx.check(v, Value, value, key)\n        }\n      }\n    },\n  })\n}\n\n/**\n * Ensure that a value matches one of a set of types.\n */\n\nexport function union<A>(Structs: TupleSchema<[A]>): Struct<A, null>\nexport function union<A, B>(Structs: TupleSchema<[A, B]>): Struct<A | B, null>\nexport function union<A, B, C>(\n  Structs: TupleSchema<[A, B, C]>\n): Struct<A | B | C, null>\nexport function union<A, B, C, D>(\n  Structs: TupleSchema<[A, B, C, D]>\n): Struct<A | B | C | D, null>\nexport function union<A, B, C, D, E>(\n  Structs: TupleSchema<[A, B, C, D, E]>\n): Struct<A | B | C | D | E, null>\nexport function union<A, B, C, D, E, F>(\n  Structs: TupleSchema<[A, B, C, D, E, F]>\n): Struct<A | B | C | D | E | F, null>\nexport function union<A, B, C, D, E, F, G>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G]>\n): Struct<A | B | C | D | E | F | G, null>\nexport function union<A, B, C, D, E, F, G, H>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H]>\n): Struct<A | B | C | D | E | F | G | H, null>\nexport function union<A, B, C, D, E, F, G, H, I>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I]>\n): Struct<A | B | C | D | E | F | G | H | I, null>\nexport function union<A, B, C, D, E, F, G, H, I, J>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J]>\n): Struct<A | B | C | D | E | F | G | H | I | J, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N | O, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\n): Struct<\n  A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q,\n  null\n>\nexport function union(Structs: Struct<any>[]): any {\n  const description = Structs.map((s) => s.type).join(' | ')\n  return define('union', function* (value, ctx) {\n    const failures = []\n\n    for (const S of Structs) {\n      const [...array] = ctx.check(value, S)\n\n      if (array.length === 0) {\n        return\n      } else {\n        failures.push(...array)\n      }\n    }\n\n    yield ctx.fail(\n      `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(\n        value\n      )}`\n    )\n\n    yield* failures\n  })\n}\n\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\n\nexport function unknown(): Struct<unknown, null> {\n  return define('unknown', () => true)\n}\n","import { Struct, is } from '../struct'\nimport { isPlainObject } from '../utils'\nimport { string, unknown } from './types'\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationâ€”for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function coerce<T, S, C>(\n  struct: Struct<T, S>,\n  condition: Struct<C, any>,\n  coercer: (value: C) => any\n): Struct<T, S> {\n  const fn = struct.coercer\n  return new Struct({\n    ...struct,\n    coercer: (value) => {\n      if (is(value, condition)) {\n        return fn(coercer(value))\n      } else {\n        return fn(value)\n      }\n    },\n  })\n}\n\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function defaulted<T, S>(\n  S: Struct<T, S>,\n  fallback: any,\n  options: {\n    strict?: boolean\n  } = {}\n): Struct<T, S> {\n  const { strict } = options\n  return coerce(S, unknown(), (x) => {\n    const f = typeof fallback === 'function' ? fallback() : fallback\n\n    if (x === undefined) {\n      return f\n    }\n\n    if (!strict && isPlainObject(x) && isPlainObject(f)) {\n      const ret = { ...x }\n      let changed = false\n\n      for (const key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key]\n          changed = true\n        }\n      }\n\n      if (changed) {\n        return ret\n      }\n    }\n\n    return x\n  })\n}\n\n/**\n * Augment a struct to mask its input to only properties defined in the struct.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function masked<T, S>(struct: Struct<T, S>): Struct<T, S> {\n  return coerce(struct, unknown(), (x) => {\n    if (\n      typeof struct.schema !== 'object' ||\n      struct.schema == null ||\n      typeof x !== 'object' ||\n      x == null\n    ) {\n      return x\n    } else {\n      const ret: any = {}\n\n      for (const key in struct.schema) {\n        if (key in x) {\n          ret[key] = (x as any)[key]\n        }\n      }\n\n      return ret\n    }\n  })\n}\n\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function trimmed<T, S>(struct: Struct<T, S>): Struct<T, S> {\n  return coerce(struct, string(), (x) => x.trim())\n}\n","import { toFailures, shiftIterator, print, StructSchema } from './utils'\nimport { StructError, Failure } from './error'\nimport { masked } from './structs/coercions'\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\n\nexport class Struct<T = unknown, S = unknown> {\n  readonly TYPE!: T\n  type: string\n  schema: S\n  coercer: Coercer\n  validator: Validator<T, S>\n  refiner: Refiner<T, S>\n\n  constructor(props: {\n    type: Struct<T, S>['type']\n    schema: Struct<T, S>['schema']\n    coercer?: Struct<T, S>['coercer']\n    validator?: Struct<T, S>['validator']\n    refiner?: Struct<T, S>['refiner']\n  }) {\n    this.type = props.type\n    this.schema = props.schema\n    this.coercer = props.coercer || ((value: unknown) => value)\n    this.validator = props.validator || (() => [])\n    this.refiner = props.refiner || (() => [])\n  }\n\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n\n  assert(value: unknown): asserts value is T {\n    return assert(value, this)\n  }\n\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n\n  create(value: unknown): T {\n    return create(value, this)\n  }\n\n  /**\n   * Check if a value passes the struct's validation.\n   */\n\n  is(value: unknown): value is T {\n    return is(value, this)\n  }\n\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */\n\n  mask(value: unknown): T {\n    return mask(value, this)\n  }\n\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */\n\n  validate(\n    value: unknown,\n    options: {\n      coerce?: boolean\n    } = {}\n  ): [StructError, undefined] | [undefined, T] {\n    return validate(value, this, options)\n  }\n}\n\n/**\n * A `StructContext` contains information about the current value being\n * validated as well as helper functions for failures and recursive validating.\n */\n\nexport type Context<T, S> = {\n  value: any\n  struct: Struct<T, S>\n  branch: Array<any>\n  path: Array<string | number>\n  fail: (props?: string | Partial<Failure>) => Failure\n  check: <Y, Z>(\n    value: any,\n    struct: Struct<Y, Z>,\n    parent?: any,\n    key?: string | number\n  ) => IterableIterator<Failure>\n}\n\n/**\n * A type utility to extract the type from a `Struct` class.\n */\n\nexport type Infer<T extends Struct<any, any>> = T['TYPE']\n\n/**\n * A type utility to describe that a struct represents a TypeScript type.\n */\n\nexport type Describe<T> = Struct<T, StructSchema<T>>\n\n/**\n * A `Result` is returned from validation functions.\n */\n\nexport type Result = boolean | string | Iterable<Failure>\n\n/**\n * A `Coercer` takes an unknown value and optionally coerces it.\n */\n\nexport type Coercer = (value: unknown) => unknown\n\n/**\n * A `Validate` takes an unknown value and validates it.\n */\n\nexport type Validator<T, S> = (value: unknown, context: Context<T, S>) => Result\n\n/**\n * A `Refiner` takes a value of a known type and validates it against a further\n * constraint.\n */\n\nexport type Refiner<T, S> = (value: T, context: Context<T, S>) => Result\n\n/**\n * Assert that a value passes a `Struct`, throwing if it doesn't.\n */\n\nexport function assert<T, S>(\n  value: unknown,\n  struct: Struct<T, S>\n): asserts value is T {\n  const result = validate(value, struct)\n\n  if (result[0]) {\n    throw result[0]\n  }\n}\n\n/**\n * Create a value with the coercion logic of `Struct` and validate it.\n */\n\nexport function create<T, S>(value: unknown, struct: Struct<T, S>): T {\n  const ret = struct.coercer(value)\n  assert(ret, struct)\n  return ret\n}\n\n/**\n * Mask a value, returning only the subset of properties defined by a Struct.\n */\n\nexport function mask<T, S>(value: unknown, struct: Struct<T, S>): T {\n  const M = masked(struct)\n  const ret = create(value, M)\n  return ret\n}\n\n/**\n * Check if a value passes a `Struct`.\n */\n\nexport function is<T, S>(value: unknown, struct: Struct<T, S>): value is T {\n  const result = validate(value, struct)\n  return !result[0]\n}\n\n/**\n * Validate a value against a `Struct`, returning an error if invalid.\n */\n\nexport function validate<T, S>(\n  value: unknown,\n  struct: Struct<T, S>,\n  options: {\n    coerce?: boolean\n  } = {}\n): [StructError, undefined] | [undefined, T] {\n  if (options.coerce) {\n    value = struct.coercer(value)\n  }\n\n  const failures = check(value, struct)\n  const failure = shiftIterator(failures)\n\n  if (failure) {\n    const error = new StructError(failure, failures)\n    return [error, undefined]\n  } else {\n    return [undefined, value as T]\n  }\n}\n\n/**\n * Check a value against a `Struct`, returning an iterable of failures.\n */\n\nfunction* check<T, S>(\n  value: unknown,\n  struct: Struct<T, S>,\n  path: any[] = [],\n  branch: any[] = []\n): IterableIterator<Failure> {\n  const ctx: Context<T, S> = {\n    value,\n    struct,\n    branch,\n    path,\n    check(v, s, parent, key) {\n      const p = parent !== undefined ? [...path, key] : path\n      const b = parent !== undefined ? [...branch, parent] : branch\n      return check(v, s, p, b)\n    },\n    fail(props = {}) {\n      if (typeof props === 'string') {\n        props = { message: props }\n      }\n\n      const { type } = struct\n      let { message, refinement } = props\n\n      if (!message) {\n        message = `Expected a value of type \\`${type}\\`${\n          refinement ? ` with refinement \\`${refinement}\\`` : ''\n        }${\n          path.length ? ` for \\`${path.join('.')}\\`` : ''\n        }, but received: \\`${print(value)}\\``\n      }\n\n      return {\n        ...props,\n        value,\n        type,\n        refinement,\n        message,\n        key: path[path.length - 1],\n        path,\n        branch: [...branch, value],\n      }\n    },\n  }\n\n  const failures = toFailures(struct.validator(value, ctx), ctx)\n  const failure = shiftIterator(failures)\n\n  if (failure) {\n    yield failure\n    yield* failures\n  } else {\n    yield* toFailures(struct.refiner(value as T, ctx), ctx)\n  }\n}\n","import { Struct, Refiner } from '../struct'\nimport { toFailures } from '../utils'\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\n\nexport function empty<T extends string | any[] | Map<any, any> | Set<any>>(\n  struct: Struct<T>\n): Struct<T> {\n  const expected = `Expected an empty ${struct.type}`\n\n  return refine(struct, 'empty', (value) => {\n    if (value instanceof Map || value instanceof Set) {\n      const { size } = value\n      return (\n        size === 0 || `${expected} but received one with a size of \\`${size}\\``\n      )\n    } else {\n      const { length } = value as string | any[]\n      return (\n        length === 0 ||\n        `${expected} but received one with a length of \\`${length}\\``\n      )\n    }\n  })\n}\n\n/**\n * Ensure that a number or date is below a threshold.\n */\n\nexport function max<T extends number | Date>(\n  struct: Struct<T>,\n  threshold: T,\n  options: {\n    exclusive?: boolean\n  } = {}\n): Struct<T> {\n  const { exclusive } = options\n  return refine(struct, 'max', (value) => {\n    return exclusive\n      ? value < threshold\n      : value <= threshold ||\n          `Expected a ${struct.type} greater than ${\n            exclusive ? '' : 'or equal to '\n          }${threshold} but received \\`${value}\\``\n  })\n}\n\n/**\n * Ensure that a number or date is above a threshold.\n */\n\nexport function min<T extends number | Date>(\n  struct: Struct<T>,\n  threshold: T,\n  options: {\n    exclusive?: boolean\n  } = {}\n): Struct<T> {\n  const { exclusive } = options\n  return refine(struct, 'min', (value) => {\n    return exclusive\n      ? value > threshold\n      : value >= threshold ||\n          `Expected a ${struct.type} greater than ${\n            exclusive ? '' : 'or equal to '\n          }${threshold} but received \\`${value}\\``\n  })\n}\n/**\n * Ensure that a string matches a regular expression.\n */\n\nexport function pattern<T extends string>(\n  struct: Struct<T>,\n  regexp: RegExp\n): Struct<T> {\n  return refine(struct, 'pattern', (value) => {\n    return (\n      regexp.test(value) ||\n      `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`\n    )\n  })\n}\n\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\n\nexport function size<\n  T extends string | number | Date | any[] | Map<any, any> | Set<any>\n>(struct: Struct<T>, min: number, max: number = min): Struct<T> {\n  const expected = `Expected a ${struct.type}`\n  const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``\n\n  return refine(struct, 'size', (value) => {\n    if (typeof value === 'number' || value instanceof Date) {\n      return (\n        (min <= value && value <= max) ||\n        `${expected} ${of} but received \\`${value}\\``\n      )\n    } else if (value instanceof Map || value instanceof Set) {\n      const { size } = value\n      return (\n        (min <= size && size <= max) ||\n        `${expected} with a size ${of} but received one with a size of \\`${size}\\``\n      )\n    } else {\n      const { length } = value as string | any[]\n      return (\n        (min <= length && length <= max) ||\n        `${expected} with a length ${of} but received one with a length of \\`${length}\\``\n      )\n    }\n  })\n}\n\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\n\nexport function refine<T, S>(\n  struct: Struct<T, S>,\n  name: string,\n  refiner: Refiner<T, S>\n): Struct<T, S> {\n  const fn = struct.refiner\n  return new Struct({\n    ...struct,\n    *refiner(value, ctx) {\n      yield* toFailures(fn(value, ctx), ctx)\n\n      for (const failure of toFailures(refiner(value, ctx), ctx)) {\n        yield { ...failure, refinement: name }\n      }\n    },\n  })\n}\n"],"names":["StructError","TypeError","constructor","failure","moreFailures","message","rest","path","failures","msg","length","join","Object","assign","name","isPlainObject","value","prototype","toString","call","getPrototypeOf","print","JSON","stringify","shiftIterator","input","done","next","undefined","toFailures","result","context","fail","Structs","schemas","map","s","schema","object","define","validator","Struct","type","dynamic","fn","ctx","check","lazy","omit","struct","keys","subschema","key","partial","optional","pick","console","warn","any","array","Element","coercer","Array","isArray","v","i","entries","boolean","date","Date","isNaN","getTime","enums","values","description","includes","func","instance","Class","integer","Number","isInteger","intersection","S","literal","constant","Key","Value","Map","k","never","nullable","refiner","c","number","knowns","Never","unknowns","Set","delete","ret","record","regexp","RegExp","set","val","string","tuple","Elements","index","union","push","unknown","coerce","condition","is","defaulted","fallback","options","strict","x","f","changed","masked","trimmed","trim","props","assert","create","mask","validate","M","error","branch","parent","p","b","refinement","empty","expected","refine","size","max","threshold","exclusive","min","pattern","test","source","of"],"mappings":"AAAA;;;;AAcA;;;;;;;;MASaA,oBAAoBC;AAU/BC,EAAAA,YAAYC,SAAkBC;AAC5B,UAAM;AAAEC,MAAAA,OAAF;AAAW,SAAGC;AAAd,QAAuBH,OAA7B;AACA,UAAM;AAAEI,MAAAA;AAAF,QAAWJ,OAAjB;AACA,QAAIK,QAAJ;AACA,UAAMC,GAAG,GACPF,IAAI,CAACG,MAAL,KAAgB,CAAhB,GAAoBL,OAApB,iBAA0CE,IAAI,CAACI,IAAL,CAAU,GAAV,CAA1C,YAA+DN,OADjE;AAEA,UAAMI,GAAN;AACAG,IAAAA,MAAM,CAACC,MAAP,CAAc,IAAd,EAAoBP,IAApB;AACA,SAAKQ,IAAL,GAAY,KAAKZ,WAAL,CAAiBY,IAA7B;;AACA,SAAKN,QAAL,GAAgB;AACd,UAAI,CAACA,QAAL,EAAe;AACbA,QAAAA,QAAQ,GAAG,CAACL,OAAD,EAAU,GAAGC,YAAb,CAAX;AACD;;AAED,aAAOI,QAAP;AACD,KAND;AAOD;;;;AC9CH;;;SAIgBO,cAAcC;AAC5B,MAAIJ,MAAM,CAACK,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BH,KAA/B,MAA0C,iBAA9C,EAAiE;AAC/D,WAAO,KAAP;AACD;;AAED,QAAMC,SAAS,GAAGL,MAAM,CAACQ,cAAP,CAAsBJ,KAAtB,CAAlB;AACA,SAAOC,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAKL,MAAM,CAACK,SAAlD;AACD;AAED;;;;SAIgBI,MAAML;AACpB,SAAO,OAAOA,KAAP,KAAiB,QAAjB,GAA4BM,IAAI,CAACC,SAAL,CAAeP,KAAf,CAA5B,QAAuDA,KAA9D;AACD;AAED;;;;;SAKgBQ,cAAiBC;AAC/B,QAAM;AAAEC,IAAAA,IAAF;AAAQV,IAAAA;AAAR,MAAkBS,KAAK,CAACE,IAAN,EAAxB;AACA,SAAOD,IAAI,GAAGE,SAAH,GAAeZ,KAA1B;AACD;AAED;;;;UAIiBa,WACfC,QACAC;AAEA,MAAI,OAAOD,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,UAAMC,OAAO,CAACC,IAAR,CAAa;AAAE3B,MAAAA,OAAO,EAAEyB;AAAX,KAAb,CAAN;AACD,GAFD,MAEO,IAAIA,MAAM,KAAK,IAAf,EAAqB;AAC1B;AACD,GAFM,MAEA,IAAIA,MAAM,KAAK,KAAf,EAAsB;AAC3B,UAAMC,OAAO,CAACC,IAAR,EAAN;AACD,GAFM,MAEA;AACL,WAAOF,MAAP;AACD;AACF;;SCGejB,OAAO,GAAGoB;AACxB,QAAMC,OAAO,GAAGD,OAAO,CAACE,GAAR,CAAaC,CAAD,IAAOA,CAAC,CAACC,MAArB,CAAhB;AACA,QAAMA,MAAM,GAAGzB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,GAAGqB,OAArB,CAAf;AACA,SAAOI,MAAM,CAACD,MAAD,CAAb;AACD;AAED;;;;SAIgBE,OACdzB,MACA0B;AAEA,SAAO,IAAIC,MAAJ,CAAW;AAAEC,IAAAA,IAAI,EAAE5B,IAAR;AAAcuB,IAAAA,MAAM,EAAE,IAAtB;AAA4BG,IAAAA;AAA5B,GAAX,CAAP;AACD;AAED;;;;;;;;SAQgBG,QACdC;AAEA,SAAOL,MAAM,CAAC,SAAD,EAAY,CAACvB,KAAD,EAAQ6B,GAAR;AACvB,WAAOA,GAAG,CAACC,KAAJ,CAAU9B,KAAV,EAAiB4B,EAAE,CAAC5B,KAAD,EAAQ6B,GAAR,CAAnB,CAAP;AACD,GAFY,CAAb;AAGD;AAED;;;;;;;;;SASgBE,KAAQH;AACtB,MAAIR,CAAJ;AAEA,SAAOG,MAAM,CAAC,MAAD,EAAS,CAACvB,KAAD,EAAQ6B,GAAR;AACpB,QAAI,CAACT,CAAL,EAAQ;AACNA,MAAAA,CAAC,GAAGQ,EAAE,EAAN;AACD;;AAED,WAAOC,GAAG,CAACC,KAAJ,CAAU9B,KAAV,EAAiBoB,CAAjB,CAAP;AACD,GANY,CAAb;AAOD;AAED;;;;;;;SAOgBY,KACdC,QACAC;AAEA,QAAM;AAAEb,IAAAA;AAAF,MAAaY,MAAnB;AACA,QAAME,SAAS,GAAQ,EAAE,GAAGd;AAAL,GAAvB;;AAEA,OAAK,MAAMe,GAAX,IAAkBF,IAAlB,EAAwB;AACtB,WAAOC,SAAS,CAACC,GAAD,CAAhB;AACD;;AAED,SAAOd,MAAM,CAACa,SAAD,CAAb;AACD;AAED;;;;;;;SAOgBE,QACdJ;AAEA,QAAMZ,MAAM,GACVY,MAAM,YAAYR,MAAlB,GAA2B,EAAE,GAAGQ,MAAM,CAACZ;AAAZ,GAA3B,GAAkD,EAAE,GAAGY;AAAL,GADpD;;AAGA,OAAK,MAAMG,GAAX,IAAkBf,MAAlB,EAA0B;AACxBA,IAAAA,MAAM,CAACe,GAAD,CAAN,GAAcE,QAAQ,CAACjB,MAAM,CAACe,GAAD,CAAP,CAAtB;AACD;;AAED,SAAOd,MAAM,CAACD,MAAD,CAAb;AACD;AAED;;;;;;;SAOgBkB,KACdN,QACAC;AAEA,QAAM;AAAEb,IAAAA;AAAF,MAAaY,MAAnB;AACA,QAAME,SAAS,GAAQ,EAAvB;;AAEA,OAAK,MAAMC,GAAX,IAAkBF,IAAlB,EAAwB;AACtBC,IAAAA,SAAS,CAACC,GAAD,CAAT,GAAiBf,MAAM,CAACe,GAAD,CAAvB;AACD;;AAED,SAAOd,MAAM,CAACa,SAAD,CAAb;AACD;AAED;;;;;;SAMgBF,OACdnC,MACA0B;AAEAgB,EAAAA,OAAO,CAACC,IAAR,CACE,sEADF;AAIA,SAAOlB,MAAM,CAACzB,IAAD,EAAO0B,SAAP,CAAb;AACD;;AC/KD;;;;SAIgBkB;AACd,SAAOnB,MAAM,CAAC,KAAD,EAAQ,MAAM,IAAd,CAAb;AACD;SAYeoB,MAA6BC;AAC3C,SAAO,IAAInB,MAAJ,CAAW;AAChBC,IAAAA,IAAI,EAAE,OADU;AAEhBL,IAAAA,MAAM,EAAEuB,OAFQ;AAGhBC,IAAAA,OAAO,EAAG7C,KAAD;AACP,aAAO4C,OAAO,IAAIE,KAAK,CAACC,OAAN,CAAc/C,KAAd,CAAX,GACHA,KAAK,CAACmB,GAAN,CAAW6B,CAAD,IAAOJ,OAAO,CAACC,OAAR,CAAgBG,CAAhB,CAAjB,CADG,GAEHhD,KAFJ;AAGD,KAPe;;AAQhB,KAACwB,SAAD,CAAWxB,KAAX,EAAkB6B,GAAlB;AACE,UAAI,CAACiB,KAAK,CAACC,OAAN,CAAc/C,KAAd,CAAL,EAA2B;AACzB,cAAM6B,GAAG,CAACb,IAAJ,6CAAmDX,KAAK,CAACL,KAAD,CAAxD,CAAN;AACD,OAFD,MAEO,IAAI4C,OAAJ,EAAa;AAClB,aAAK,MAAM,CAACK,CAAD,EAAID,CAAJ,CAAX,IAAqBhD,KAAK,CAACkD,OAAN,EAArB,EAAsC;AACpC,iBAAOrB,GAAG,CAACC,KAAJ,CAAUkB,CAAV,EAAaJ,OAAb,EAAsB5C,KAAtB,EAA6BiD,CAA7B,CAAP;AACD;AACF;AACF;;AAhBe,GAAX,CAAP;AAkBD;AAED;;;;SAIgBE;AACd,SAAO5B,MAAM,CAAC,SAAD,EAAavB,KAAD;AACvB,WAAO,OAAOA,KAAP,KAAiB,SAAxB;AACD,GAFY,CAAb;AAGD;AAED;;;;;;;SAOgBoD;AACd,SAAO7B,MAAM,CAAC,MAAD,EAAUvB,KAAD;AACpB,WACGA,KAAK,YAAYqD,IAAjB,IAAyB,CAACC,KAAK,CAACtD,KAAK,CAACuD,OAAN,EAAD,CAAhC,uDACmDlD,KAAK,CAACL,KAAD,CAF1D;AAID,GALY,CAAb;AAMD;SAeewD,MAAiCC;AAC/C,QAAMpC,MAAM,GAAQ,EAApB;AACA,QAAMqC,WAAW,GAAGD,MAAM,CAACtC,GAAP,CAAY6B,CAAD,IAAO3C,KAAK,CAAC2C,CAAD,CAAvB,EAA4BrD,IAA5B,EAApB;;AAEA,OAAK,MAAMyC,GAAX,IAAkBqB,MAAlB,EAA0B;AACxBpC,IAAAA,MAAM,CAACe,GAAD,CAAN,GAAcA,GAAd;AACD;;AAED,SAAO,IAAIX,MAAJ,CAAW;AAChBC,IAAAA,IAAI,EAAE,OADU;AAEhBL,IAAAA,MAFgB;AAGhBG,IAAAA,SAAS,EAAGxB,KAAD;AACT,aACEyD,MAAM,CAACE,QAAP,CAAgB3D,KAAhB,2BACqB0D,WADrB,yBACqDrD,KAAK,CAACL,KAAD,CAF5D;AAID;AARe,GAAX,CAAP;AAUD;AAED;;;;SAIgB4D;AACd,SAAOrC,MAAM,CAAC,MAAD,EAAUvB,KAAD;AACpB,WACE,OAAOA,KAAP,KAAiB,UAAjB,4CACsCK,KAAK,CAACL,KAAD,CAF7C;AAID,GALY,CAAb;AAMD;AAED;;;;SAIgB6D,SACdC;AAEA,SAAOvC,MAAM,CAAC,UAAD,EAAcvB,KAAD;AACxB,WACEA,KAAK,YAAY8D,KAAjB,qBACgBA,KAAK,CAAChE,IADtB,kCACwDO,KAAK,CAACL,KAAD,CAF/D;AAID,GALY,CAAb;AAMD;AAED;;;;SAIgB+D;AACd,SAAOxC,MAAM,CAAC,SAAD,EAAavB,KAAD;AACvB,WACG,OAAOA,KAAP,KAAiB,QAAjB,IAA6B,CAACsD,KAAK,CAACtD,KAAD,CAAnC,IAA8CgE,MAAM,CAACC,SAAP,CAAiBjE,KAAjB,CAA/C,4CACsCK,KAAK,CAACL,KAAD,CAF7C;AAID,GALY,CAAb;AAMD;SA0DekE,aAAajD;AAC3B,SAAOM,MAAM,CAAC,cAAD,EAAiB,WAAWvB,KAAX,EAAkB6B,GAAlB;AAC5B,SAAK,MAAMsC,CAAX,IAAgBlD,OAAhB,EAAyB;AACvB,aAAOY,GAAG,CAACC,KAAJ,CAAU9B,KAAV,EAAiBmE,CAAjB,CAAP;AACD;AACF,GAJY,CAAb;AAKD;SAUeC,QAAWC;AACzB,QAAMX,WAAW,GAAGrD,KAAK,CAACgE,QAAD,CAAzB;AACA,SAAO9C,MAAM,CAAC,SAAD,EAAavB,KAAD;AACvB,WACEA,KAAK,KAAKqE,QAAV,+BAC0BX,WAD1B,yBAC0DrD,KAAK,CAACL,KAAD,CAFjE;AAID,GALY,CAAb;AAMD;SAYemB,IAAUmD,KAAiBC;AACzC,SAAOhD,MAAM,CAAC,KAAD,EAAQ,WAAWvB,KAAX,EAAkB6B,GAAlB;AACnB,QAAI,EAAE7B,KAAK,YAAYwE,GAAnB,CAAJ,EAA6B;AAC3B,YAAM3C,GAAG,CAACb,IAAJ,6CAAqDX,KAAK,CAACL,KAAD,CAA1D,CAAN;AACD,KAFD,MAEO,IAAIsE,GAAG,IAAIC,KAAX,EAAkB;AACvB,WAAK,MAAM,CAACE,CAAD,EAAIzB,CAAJ,CAAX,IAAqBhD,KAAK,CAACkD,OAAN,EAArB,EAAsC;AACpC,eAAOrB,GAAG,CAACC,KAAJ,CAAU2C,CAAV,EAAaH,GAAb,EAAkBtE,KAAlB,EAAyByE,CAAzB,CAAP;AACA,eAAO5C,GAAG,CAACC,KAAJ,CAAUkB,CAAV,EAAauB,KAAb,EAAoBvE,KAApB,EAA2ByE,CAA3B,CAAP;AACD;AACF;AACF,GATY,CAAb;AAUD;AAED;;;;SAIgBC;AACd,SAAOnD,MAAM,CAAC,OAAD,EAAU,MAAM,KAAhB,CAAb;AACD;AAED;;;;SAIgBoD,SAAe1C;AAC7B,QAAM;AAAE2C,IAAAA;AAAF,MAAc3C,MAApB;AACA,SAAO,IAAIR,MAAJ,CAAW,EAChB,GAAGQ,MADa;AAEhBT,IAAAA,SAAS,EAAE,CAACxB,KAAD,EAAQ6B,GAAR;AACT,aAAO7B,KAAK,KAAK,IAAV,IAAkB6B,GAAG,CAACC,KAAJ,CAAU9B,KAAV,EAAiBiC,MAAjB,CAAzB;AACD,KAJe;AAKhB2C,IAAAA,OAAO,EAAE,WAAW5E,KAAX,EAAkB6B,GAAlB;AACP,UAAI7B,KAAK,IAAI,IAAb,EAAmB;AACjB,cAAM6E,CAAC,GAAG,EAAE,GAAGhD,GAAL;AAAUI,UAAAA;AAAV,SAAV;AACA,eAAOpB,UAAU,CAAC+D,OAAO,CAAC5E,KAAD,EAAQ6E,CAAR,CAAR,EAAoBA,CAApB,CAAjB;AACD;AACF;AAVe,GAAX,CAAP;AAYD;AAED;;;;SAIgBC;AACd,SAAOvD,MAAM,CAAC,QAAD,EAAYvB,KAAD;AACtB,WACG,OAAOA,KAAP,KAAiB,QAAjB,IAA6B,CAACsD,KAAK,CAACtD,KAAD,CAApC,0CACoCK,KAAK,CAACL,KAAD,CAF3C;AAID,GALY,CAAb;AAMD;SAaesB,OAA+BD;AAC7C,QAAM0D,MAAM,GAAG1D,MAAM,GAAGzB,MAAM,CAACsC,IAAP,CAAYb,MAAZ,CAAH,GAAyB,EAA9C;AACA,QAAM2D,KAAK,GAAGN,KAAK,EAAnB;AACA,SAAO,IAAIjD,MAAJ,CAAW;AAChBC,IAAAA,IAAI,EAAE,QADU;AAEhBL,IAAAA,MAAM,EAAEA,MAAM,GAAGA,MAAH,GAAY,IAFV;;AAGhB,KAACG,SAAD,CAAWxB,KAAX,EAAkB6B,GAAlB;AACE,UAAI,OAAO7B,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,IAAI,IAA1C,EAAgD;AAC9C,cAAM6B,GAAG,CAACb,IAAJ,wCAA8CX,KAAK,CAACL,KAAD,CAAnD,CAAN;AACD,OAFD,MAEO,IAAIqB,MAAJ,EAAY;AACjB,cAAM4D,QAAQ,GAAG,IAAIC,GAAJ,CAAQtF,MAAM,CAACsC,IAAP,CAAYlC,KAAZ,CAAR,CAAjB;;AAEA,aAAK,MAAMoC,GAAX,IAAkB2C,MAAlB,EAA0B;AACxBE,UAAAA,QAAQ,CAACE,MAAT,CAAgB/C,GAAhB;AACA,gBAAMmC,KAAK,GAAGlD,MAAM,CAACe,GAAD,CAApB;AACA,gBAAMY,CAAC,GAAGhD,KAAK,CAACoC,GAAD,CAAf;AACA,iBAAOP,GAAG,CAACC,KAAJ,CAAUkB,CAAV,EAAauB,KAAb,EAAoBvE,KAApB,EAA2BoC,GAA3B,CAAP;AACD;;AAED,aAAK,MAAMA,GAAX,IAAkB6C,QAAlB,EAA4B;AAC1B,gBAAMjC,CAAC,GAAGhD,KAAK,CAACoC,GAAD,CAAf;AACA,iBAAOP,GAAG,CAACC,KAAJ,CAAUkB,CAAV,EAAagC,KAAb,EAAoBhF,KAApB,EAA2BoC,GAA3B,CAAP;AACD;AACF;AACF,KArBe;;AAsBhBS,IAAAA,OAAO,EAAG7C,KAAD;AACP,UAAI,CAACqB,MAAD,IAAW,OAAOrB,KAAP,KAAiB,QAA5B,IAAwCA,KAAK,IAAI,IAArD,EAA2D;AACzD,eAAOA,KAAP;AACD;;AAED,YAAMoF,GAAG,GAAG,EAAZ;AACA,YAAMH,QAAQ,GAAG,IAAIC,GAAJ,CAAQtF,MAAM,CAACsC,IAAP,CAAYlC,KAAZ,CAAR,CAAjB;;AAEA,WAAK,MAAMoC,GAAX,IAAkB2C,MAAlB,EAA0B;AACxBE,QAAAA,QAAQ,CAACE,MAAT,CAAgB/C,GAAhB;AACA,cAAMmC,KAAK,GAAGlD,MAAM,CAACe,GAAD,CAApB;AACA,cAAMY,CAAC,GAAGhD,KAAK,CAACoC,GAAD,CAAf;AACAgD,QAAAA,GAAG,CAAChD,GAAD,CAAH,GAAWmC,KAAK,CAAC1B,OAAN,CAAcG,CAAd,CAAX;AACD;;AAED,WAAK,MAAMZ,GAAX,IAAkB6C,QAAlB,EAA4B;AAC1BG,QAAAA,GAAG,CAAChD,GAAD,CAAH,GAAWpC,KAAK,CAACoC,GAAD,CAAhB;AACD;;AAED,aAAOgD,GAAP;AACD;AA1Ce,GAAX,CAAP;AA4CD;AAED;;;;SAIgB9C,SAAeL;AAC7B,QAAM;AAAE2C,IAAAA;AAAF,MAAc3C,MAApB;AACA,SAAO,IAAIR,MAAJ,CAAW,EAChB,GAAGQ,MADa;AAEhBT,IAAAA,SAAS,EAAE,CAACxB,KAAD,EAAQ6B,GAAR;AACT,aAAO7B,KAAK,KAAKY,SAAV,IAAuBiB,GAAG,CAACC,KAAJ,CAAU9B,KAAV,EAAiBiC,MAAjB,CAA9B;AACD,KAJe;AAKhB2C,IAAAA,OAAO,EAAE,WAAW5E,KAAX,EAAkB6B,GAAlB;AACP,UAAI7B,KAAK,IAAI,IAAb,EAAmB;AACjB,cAAM6E,CAAC,GAAG,EAAE,GAAGhD,GAAL;AAAUI,UAAAA;AAAV,SAAV;AACA,eAAOpB,UAAU,CAAC+D,OAAO,CAAC5E,KAAD,EAAQ6E,CAAR,CAAR,EAAoBA,CAApB,CAAjB;AACD;AACF;AAVe,GAAX,CAAP;AAYD;AAED;;;;;;;SAOgBQ,OACdf,KACAC;AAEA,SAAOhD,MAAM,CAAC,QAAD,EAAW,WAAWvB,KAAX,EAAkB6B,GAAlB;AACtB,QAAI,OAAO7B,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,IAAI,IAA1C,EAAgD;AAC9C,YAAM6B,GAAG,CAACb,IAAJ,wCAA8CX,KAAK,CAACL,KAAD,CAAnD,CAAN;AACD,KAFD,MAEO;AACL,WAAK,MAAMyE,CAAX,IAAgBzE,KAAhB,EAAuB;AACrB,cAAMgD,CAAC,GAAGhD,KAAK,CAACyE,CAAD,CAAf;AACA,eAAO5C,GAAG,CAACC,KAAJ,CAAU2C,CAAV,EAAaH,GAAb,EAAkBtE,KAAlB,EAAyByE,CAAzB,CAAP;AACA,eAAO5C,GAAG,CAACC,KAAJ,CAAUkB,CAAV,EAAauB,KAAb,EAAoBvE,KAApB,EAA2ByE,CAA3B,CAAP;AACD;AACF;AACF,GAVY,CAAb;AAWD;AAED;;;;;;;SAOgBa;AACd,SAAO/D,MAAM,CAAC,QAAD,EAAYvB,KAAD;AACtB,WAAOA,KAAK,YAAYuF,MAAxB;AACD,GAFY,CAAb;AAGD;SASeC,IAAO5C;AACrB,SAAOrB,MAAM,CAAC,KAAD,EAAQ,WAAWvB,KAAX,EAAkB6B,GAAlB;AACnB,QAAI,EAAE7B,KAAK,YAAYkF,GAAnB,CAAJ,EAA6B;AAC3B,YAAMrD,GAAG,CAACb,IAAJ,6CAAqDX,KAAK,CAACL,KAAD,CAA1D,CAAN;AACD,KAFD,MAEO,IAAI4C,OAAJ,EAAa;AAClB,WAAK,MAAM6C,GAAX,IAAkBzF,KAAlB,EAAyB;AACvB,eAAO6B,GAAG,CAACC,KAAJ,CAAU2D,GAAV,EAAe7C,OAAf,EAAwB5C,KAAxB,EAA+ByF,GAA/B,CAAP;AACD;AACF;AACF,GARY,CAAb;AASD;AAED;;;;SAIgBC;AACd,SAAOnE,MAAM,CAAC,QAAD,EAAYvB,KAAD;AACtB,WACE,OAAOA,KAAP,KAAiB,QAAjB,0CACoCK,KAAK,CAACL,KAAD,CAF3C;AAID,GALY,CAAb;AAMD;SAsDe2F,MAAMC;AACpB,QAAMZ,KAAK,GAAGN,KAAK,EAAnB;AAEA,SAAOnD,MAAM,CAAC,OAAD,EAAU,WAAWvB,KAAX,EAAkB6B,GAAlB;AACrB,QAAI,CAACiB,KAAK,CAACC,OAAN,CAAc/C,KAAd,CAAL,EAA2B;AACzB,YAAM6B,GAAG,CAACb,IAAJ,uCAA6CX,KAAK,CAACL,KAAD,CAAlD,CAAN;AACD,KAFD,MAEO;AACL,WAAK,MAAM,CAAC6F,KAAD,EAAQjD,OAAR,CAAX,IAA+BgD,QAAQ,CAAC1C,OAAT,EAA/B,EAAmD;AACjD,cAAMF,CAAC,GAAGhD,KAAK,CAAC6F,KAAD,CAAf;AACA,eAAOhE,GAAG,CAACC,KAAJ,CAAUkB,CAAV,EAAaJ,OAAb,EAAsB5C,KAAtB,EAA6B6F,KAA7B,CAAP;AACD;;AAED,UAAI7F,KAAK,CAACN,MAAN,GAAekG,QAAQ,CAAClG,MAA5B,EAAoC;AAClC,cAAMmG,KAAK,GAAGD,QAAQ,CAAClG,MAAvB;AACA,cAAMsD,CAAC,GAAGhD,KAAK,CAAC6F,KAAD,CAAf;AACA,eAAOhE,GAAG,CAACC,KAAJ,CAAUkB,CAAV,EAAagC,KAAb,EAAoBhF,KAApB,EAA2B6F,KAA3B,CAAP;AACD;AACF;AACF,GAfY,CAAb;AAgBD;AAED;;;;;;;SAOgBnE,KACdL;AAEA,QAAMa,IAAI,GAAGtC,MAAM,CAACsC,IAAP,CAAYb,MAAZ,CAAb;AACA,SAAO,IAAII,MAAJ,CAAW;AAChBC,IAAAA,IAAI,EAAE,MADU;AAEhBL,IAAAA,MAFgB;AAGhBG,IAAAA,SAAS,EAAE,WAAWxB,KAAX,EAAkB6B,GAAlB;AACT,UAAI,OAAO7B,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,IAAI,IAA1C,EAAgD;AAC9C,cAAM6B,GAAG,CAACb,IAAJ,wCAA8CX,KAAK,CAACL,KAAD,CAAnD,CAAN;AACD,OAFD,MAEO;AACL,aAAK,MAAMoC,GAAX,IAAkBF,IAAlB,EAAwB;AACtB,gBAAMqC,KAAK,GAAGlD,MAAM,CAACe,GAAD,CAApB;AACA,gBAAMY,CAAC,GAAIhD,KAAa,CAACoC,GAAD,CAAxB;AACA,iBAAOP,GAAG,CAACC,KAAJ,CAAUkB,CAAV,EAAauB,KAAb,EAAoBvE,KAApB,EAA2BoC,GAA3B,CAAP;AACD;AACF;AACF;AAbe,GAAX,CAAP;AAeD;SAwDe0D,MAAM7E;AACpB,QAAMyC,WAAW,GAAGzC,OAAO,CAACE,GAAR,CAAaC,CAAD,IAAOA,CAAC,CAACM,IAArB,EAA2B/B,IAA3B,CAAgC,KAAhC,CAApB;AACA,SAAO4B,MAAM,CAAC,OAAD,EAAU,WAAWvB,KAAX,EAAkB6B,GAAlB;AACrB,UAAMrC,QAAQ,GAAG,EAAjB;;AAEA,SAAK,MAAM2E,CAAX,IAAgBlD,OAAhB,EAAyB;AACvB,YAAM,CAAC,GAAG0B,KAAJ,IAAad,GAAG,CAACC,KAAJ,CAAU9B,KAAV,EAAiBmE,CAAjB,CAAnB;;AAEA,UAAIxB,KAAK,CAACjD,MAAN,KAAiB,CAArB,EAAwB;AACtB;AACD,OAFD,MAEO;AACLF,QAAAA,QAAQ,CAACuG,IAAT,CAAc,GAAGpD,KAAjB;AACD;AACF;;AAED,UAAMd,GAAG,CAACb,IAAJ,gDAC0C0C,WAD1C,yBAC0ErD,KAAK,CACjFL,KADiF,CAD/E,CAAN;AAMA,WAAOR,QAAP;AACD,GApBY,CAAb;AAqBD;AAED;;;;SAIgBwG;AACd,SAAOzE,MAAM,CAAC,SAAD,EAAY,MAAM,IAAlB,CAAb;AACD;;AClnBD;;;;;;;;;;;SAWgB0E,OACdhE,QACAiE,WACArD;AAEA,QAAMjB,EAAE,GAAGK,MAAM,CAACY,OAAlB;AACA,SAAO,IAAIpB,MAAJ,CAAW,EAChB,GAAGQ,MADa;AAEhBY,IAAAA,OAAO,EAAG7C,KAAD;AACP,UAAImG,EAAE,CAACnG,KAAD,EAAQkG,SAAR,CAAN,EAA0B;AACxB,eAAOtE,EAAE,CAACiB,OAAO,CAAC7C,KAAD,CAAR,CAAT;AACD,OAFD,MAEO;AACL,eAAO4B,EAAE,CAAC5B,KAAD,CAAT;AACD;AACF;AARe,GAAX,CAAP;AAUD;AAED;;;;;;;SAOgBoG,UACdjC,GACAkC,UACAC,UAEI;AAEJ,QAAM;AAAEC,IAAAA;AAAF,MAAaD,OAAnB;AACA,SAAOL,MAAM,CAAC9B,CAAD,EAAI6B,OAAO,EAAX,EAAgBQ,CAAD;AAC1B,UAAMC,CAAC,GAAG,OAAOJ,QAAP,KAAoB,UAApB,GAAiCA,QAAQ,EAAzC,GAA8CA,QAAxD;;AAEA,QAAIG,CAAC,KAAK5F,SAAV,EAAqB;AACnB,aAAO6F,CAAP;AACD;;AAED,QAAI,CAACF,MAAD,IAAWxG,aAAa,CAACyG,CAAD,CAAxB,IAA+BzG,aAAa,CAAC0G,CAAD,CAAhD,EAAqD;AACnD,YAAMrB,GAAG,GAAG,EAAE,GAAGoB;AAAL,OAAZ;AACA,UAAIE,OAAO,GAAG,KAAd;;AAEA,WAAK,MAAMtE,GAAX,IAAkBqE,CAAlB,EAAqB;AACnB,YAAIrB,GAAG,CAAChD,GAAD,CAAH,KAAaxB,SAAjB,EAA4B;AAC1BwE,UAAAA,GAAG,CAAChD,GAAD,CAAH,GAAWqE,CAAC,CAACrE,GAAD,CAAZ;AACAsE,UAAAA,OAAO,GAAG,IAAV;AACD;AACF;;AAED,UAAIA,OAAJ,EAAa;AACX,eAAOtB,GAAP;AACD;AACF;;AAED,WAAOoB,CAAP;AACD,GAxBY,CAAb;AAyBD;AAED;;;;;;;SAOgBG,OAAa1E;AAC3B,SAAOgE,MAAM,CAAChE,MAAD,EAAS+D,OAAO,EAAhB,EAAqBQ,CAAD;AAC/B,QACE,OAAOvE,MAAM,CAACZ,MAAd,KAAyB,QAAzB,IACAY,MAAM,CAACZ,MAAP,IAAiB,IADjB,IAEA,OAAOmF,CAAP,KAAa,QAFb,IAGAA,CAAC,IAAI,IAJP,EAKE;AACA,aAAOA,CAAP;AACD,KAPD,MAOO;AACL,YAAMpB,GAAG,GAAQ,EAAjB;;AAEA,WAAK,MAAMhD,GAAX,IAAkBH,MAAM,CAACZ,MAAzB,EAAiC;AAC/B,YAAIe,GAAG,IAAIoE,CAAX,EAAc;AACZpB,UAAAA,GAAG,CAAChD,GAAD,CAAH,GAAYoE,CAAS,CAACpE,GAAD,CAArB;AACD;AACF;;AAED,aAAOgD,GAAP;AACD;AACF,GAnBY,CAAb;AAoBD;AAED;;;;;;;SAOgBwB,QAAc3E;AAC5B,SAAOgE,MAAM,CAAChE,MAAD,EAASyD,MAAM,EAAf,EAAoBc,CAAD,IAAOA,CAAC,CAACK,IAAF,EAA1B,CAAb;AACD;;AC9GD;;;;;;MAMapF;AAQXvC,EAAAA,YAAY4H;AAOV,SAAKpF,IAAL,GAAYoF,KAAK,CAACpF,IAAlB;AACA,SAAKL,MAAL,GAAcyF,KAAK,CAACzF,MAApB;;AACA,SAAKwB,OAAL,GAAeiE,KAAK,CAACjE,OAAN,KAAmB7C,KAAD,IAAoBA,KAAtC,CAAf;;AACA,SAAKwB,SAAL,GAAiBsF,KAAK,CAACtF,SAAN,KAAoB,MAAM,EAA1B,CAAjB;;AACA,SAAKoD,OAAL,GAAekC,KAAK,CAAClC,OAAN,KAAkB,MAAM,EAAxB,CAAf;AACD;AAED;;;;;AAIAmC,EAAAA,MAAM,CAAC/G,KAAD;AACJ,WAAO+G,MAAM,CAAC/G,KAAD,EAAQ,IAAR,CAAb;AACD;AAED;;;;;AAIAgH,EAAAA,MAAM,CAAChH,KAAD;AACJ,WAAOgH,MAAM,CAAChH,KAAD,EAAQ,IAAR,CAAb;AACD;AAED;;;;;AAIAmG,EAAAA,EAAE,CAACnG,KAAD;AACA,WAAOmG,EAAE,CAACnG,KAAD,EAAQ,IAAR,CAAT;AACD;AAED;;;;;;AAKAiH,EAAAA,IAAI,CAACjH,KAAD;AACF,WAAOiH,IAAI,CAACjH,KAAD,EAAQ,IAAR,CAAX;AACD;AAED;;;;;;;;;;AASAkH,EAAAA,QAAQ,CACNlH,KADM,EAENsG,UAEI,EAJE;AAMN,WAAOY,QAAQ,CAAClH,KAAD,EAAQ,IAAR,EAAcsG,OAAd,CAAf;AACD;;;AA2DH;;;;SAIgBS,OACd/G,OACAiC;AAEA,QAAMnB,MAAM,GAAGoG,QAAQ,CAAClH,KAAD,EAAQiC,MAAR,CAAvB;;AAEA,MAAInB,MAAM,CAAC,CAAD,CAAV,EAAe;AACb,UAAMA,MAAM,CAAC,CAAD,CAAZ;AACD;AACF;AAED;;;;SAIgBkG,OAAahH,OAAgBiC;AAC3C,QAAMmD,GAAG,GAAGnD,MAAM,CAACY,OAAP,CAAe7C,KAAf,CAAZ;AACA+G,EAAAA,MAAM,CAAC3B,GAAD,EAAMnD,MAAN,CAAN;AACA,SAAOmD,GAAP;AACD;AAED;;;;SAIgB6B,KAAWjH,OAAgBiC;AACzC,QAAMkF,CAAC,GAAGR,MAAM,CAAC1E,MAAD,CAAhB;AACA,QAAMmD,GAAG,GAAG4B,MAAM,CAAChH,KAAD,EAAQmH,CAAR,CAAlB;AACA,SAAO/B,GAAP;AACD;AAED;;;;SAIgBe,GAASnG,OAAgBiC;AACvC,QAAMnB,MAAM,GAAGoG,QAAQ,CAAClH,KAAD,EAAQiC,MAAR,CAAvB;AACA,SAAO,CAACnB,MAAM,CAAC,CAAD,CAAd;AACD;AAED;;;;SAIgBoG,SACdlH,OACAiC,QACAqE,UAEI;AAEJ,MAAIA,OAAO,CAACL,MAAZ,EAAoB;AAClBjG,IAAAA,KAAK,GAAGiC,MAAM,CAACY,OAAP,CAAe7C,KAAf,CAAR;AACD;;AAED,QAAMR,QAAQ,GAAGsC,KAAK,CAAC9B,KAAD,EAAQiC,MAAR,CAAtB;AACA,QAAM9C,OAAO,GAAGqB,aAAa,CAAChB,QAAD,CAA7B;;AAEA,MAAIL,OAAJ,EAAa;AACX,UAAMiI,KAAK,GAAG,IAAIpI,WAAJ,CAAgBG,OAAhB,EAAyBK,QAAzB,CAAd;AACA,WAAO,CAAC4H,KAAD,EAAQxG,SAAR,CAAP;AACD,GAHD,MAGO;AACL,WAAO,CAACA,SAAD,EAAYZ,KAAZ,CAAP;AACD;AACF;AAED;;;;AAIA,UAAU8B,KAAV,CACE9B,KADF,EAEEiC,MAFF,EAGE1C,OAAc,EAHhB,EAIE8H,SAAgB,EAJlB;AAME,QAAMxF,GAAG,GAAkB;AACzB7B,IAAAA,KADyB;AAEzBiC,IAAAA,MAFyB;AAGzBoF,IAAAA,MAHyB;AAIzB9H,IAAAA,IAJyB;;AAKzBuC,IAAAA,KAAK,CAACkB,CAAD,EAAI5B,CAAJ,EAAOkG,MAAP,EAAelF,GAAf;AACH,YAAMmF,CAAC,GAAGD,MAAM,KAAK1G,SAAX,GAAuB,CAAC,GAAGrB,IAAJ,EAAU6C,GAAV,CAAvB,GAAwC7C,IAAlD;AACA,YAAMiI,CAAC,GAAGF,MAAM,KAAK1G,SAAX,GAAuB,CAAC,GAAGyG,MAAJ,EAAYC,MAAZ,CAAvB,GAA6CD,MAAvD;AACA,aAAOvF,KAAK,CAACkB,CAAD,EAAI5B,CAAJ,EAAOmG,CAAP,EAAUC,CAAV,CAAZ;AACD,KATwB;;AAUzBxG,IAAAA,IAAI,CAAC8F,KAAK,GAAG,EAAT;AACF,UAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7BA,QAAAA,KAAK,GAAG;AAAEzH,UAAAA,OAAO,EAAEyH;AAAX,SAAR;AACD;;AAED,YAAM;AAAEpF,QAAAA;AAAF,UAAWO,MAAjB;AACA,UAAI;AAAE5C,QAAAA,OAAF;AAAWoI,QAAAA;AAAX,UAA0BX,KAA9B;;AAEA,UAAI,CAACzH,OAAL,EAAc;AACZA,QAAAA,OAAO,kCAAiCqC,IAAjC,UACL+F,UAAU,0BAAyBA,UAAzB,SAA0C,EAD/C,KAGLlI,IAAI,CAACG,MAAL,cAAwBH,IAAI,CAACI,IAAL,CAAU,GAAV,CAAxB,SAA6C,EAHxC,0BAIcU,KAAK,CAACL,KAAD,CAJnB,MAAP;AAKD;;AAED,aAAO,EACL,GAAG8G,KADE;AAEL9G,QAAAA,KAFK;AAGL0B,QAAAA,IAHK;AAIL+F,QAAAA,UAJK;AAKLpI,QAAAA,OALK;AAML+C,QAAAA,GAAG,EAAE7C,IAAI,CAACA,IAAI,CAACG,MAAL,GAAc,CAAf,CANJ;AAOLH,QAAAA,IAPK;AAQL8H,QAAAA,MAAM,EAAE,CAAC,GAAGA,MAAJ,EAAYrH,KAAZ;AARH,OAAP;AAUD;;AApCwB,GAA3B;AAuCA,QAAMR,QAAQ,GAAGqB,UAAU,CAACoB,MAAM,CAACT,SAAP,CAAiBxB,KAAjB,EAAwB6B,GAAxB,CAAD,EAA+BA,GAA/B,CAA3B;AACA,QAAM1C,OAAO,GAAGqB,aAAa,CAAChB,QAAD,CAA7B;;AAEA,MAAIL,OAAJ,EAAa;AACX,UAAMA,OAAN;AACA,WAAOK,QAAP;AACD,GAHD,MAGO;AACL,WAAOqB,UAAU,CAACoB,MAAM,CAAC2C,OAAP,CAAe5E,KAAf,EAA2B6B,GAA3B,CAAD,EAAkCA,GAAlC,CAAjB;AACD;AACF;;ACzQD;;;;SAIgB6F,MACdzF;AAEA,QAAM0F,QAAQ,0BAAwB1F,MAAM,CAACP,IAA7C;AAEA,SAAOkG,MAAM,CAAC3F,MAAD,EAAS,OAAT,EAAmBjC,KAAD;AAC7B,QAAIA,KAAK,YAAYwE,GAAjB,IAAwBxE,KAAK,YAAYkF,GAA7C,EAAkD;AAChD,YAAM;AAAE2C,QAAAA;AAAF,UAAW7H,KAAjB;AACA,aACE6H,IAAI,KAAK,CAAT,IAAiBF,QAAjB,0CAA+DE,IAA/D,MADF;AAGD,KALD,MAKO;AACL,YAAM;AAAEnI,QAAAA;AAAF,UAAaM,KAAnB;AACA,aACEN,MAAM,KAAK,CAAX,IACGiI,QADH,4CACmDjI,MADnD,MADF;AAID;AACF,GAbY,CAAb;AAcD;AAED;;;;SAIgBoI,IACd7F,QACA8F,WACAzB,UAEI;AAEJ,QAAM;AAAE0B,IAAAA;AAAF,MAAgB1B,OAAtB;AACA,SAAOsB,MAAM,CAAC3F,MAAD,EAAS,KAAT,EAAiBjC,KAAD;AAC3B,WAAOgI,SAAS,GACZhI,KAAK,GAAG+H,SADI,GAEZ/H,KAAK,IAAI+H,SAAT,oBACgB9F,MAAM,CAACP,IADvB,uBAEIsG,SAAS,GAAG,EAAH,GAAQ,cAFrB,IAGKD,SAHL,uBAGiC/H,KAHjC,MAFJ;AAMD,GAPY,CAAb;AAQD;AAED;;;;SAIgBiI,IACdhG,QACA8F,WACAzB,UAEI;AAEJ,QAAM;AAAE0B,IAAAA;AAAF,MAAgB1B,OAAtB;AACA,SAAOsB,MAAM,CAAC3F,MAAD,EAAS,KAAT,EAAiBjC,KAAD;AAC3B,WAAOgI,SAAS,GACZhI,KAAK,GAAG+H,SADI,GAEZ/H,KAAK,IAAI+H,SAAT,oBACgB9F,MAAM,CAACP,IADvB,uBAEIsG,SAAS,GAAG,EAAH,GAAQ,cAFrB,IAGKD,SAHL,uBAGiC/H,KAHjC,MAFJ;AAMD,GAPY,CAAb;AAQD;AACD;;;;SAIgBkI,QACdjG,QACAqD;AAEA,SAAOsC,MAAM,CAAC3F,MAAD,EAAS,SAAT,EAAqBjC,KAAD;AAC/B,WACEsF,MAAM,CAAC6C,IAAP,CAAYnI,KAAZ,qBACciC,MAAM,CAACP,IADrB,oBACyC4D,MAAM,CAAC8C,MADhD,0BAC2EpI,KAD3E,OADF;AAID,GALY,CAAb;AAMD;AAED;;;;SAIgB6H,KAEd5F,QAAmBgG,KAAaH,MAAcG;AAC9C,QAAMN,QAAQ,mBAAiB1F,MAAM,CAACP,IAAtC;AACA,QAAM2G,EAAE,GAAGJ,GAAG,KAAKH,GAAR,YAAsBG,GAAtB,uBAA6CA,GAA7C,eAA4DH,GAA5D,MAAX;AAEA,SAAOF,MAAM,CAAC3F,MAAD,EAAS,MAAT,EAAkBjC,KAAD;AAC5B,QAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,YAAYqD,IAAlD,EAAwD;AACtD,aACG4E,GAAG,IAAIjI,KAAP,IAAgBA,KAAK,IAAI8H,GAA1B,IACGH,QADH,SACeU,EADf,uBACoCrI,KADpC,MADF;AAID,KALD,MAKO,IAAIA,KAAK,YAAYwE,GAAjB,IAAwBxE,KAAK,YAAYkF,GAA7C,EAAkD;AACvD,YAAM;AAAE2C,QAAAA;AAAF,UAAW7H,KAAjB;AACA,aACGiI,GAAG,IAAIJ,IAAP,IAAeA,IAAI,IAAIC,GAAxB,IACGH,QADH,qBAC2BU,EAD3B,0CACmER,IADnE,MADF;AAID,KANM,MAMA;AACL,YAAM;AAAEnI,QAAAA;AAAF,UAAaM,KAAnB;AACA,aACGiI,GAAG,IAAIvI,MAAP,IAAiBA,MAAM,IAAIoI,GAA5B,IACGH,QADH,uBAC6BU,EAD7B,4CACuE3I,MADvE,MADF;AAID;AACF,GAnBY,CAAb;AAoBD;AAED;;;;;;;;SAQgBkI,OACd3F,QACAnC,MACA8E;AAEA,QAAMhD,EAAE,GAAGK,MAAM,CAAC2C,OAAlB;AACA,SAAO,IAAInD,MAAJ,CAAW,EAChB,GAAGQ,MADa;;AAEhB,KAAC2C,OAAD,CAAS5E,KAAT,EAAgB6B,GAAhB;AACE,aAAOhB,UAAU,CAACe,EAAE,CAAC5B,KAAD,EAAQ6B,GAAR,CAAH,EAAiBA,GAAjB,CAAjB;;AAEA,WAAK,MAAM1C,OAAX,IAAsB0B,UAAU,CAAC+D,OAAO,CAAC5E,KAAD,EAAQ6B,GAAR,CAAR,EAAsBA,GAAtB,CAAhC,EAA4D;AAC1D,cAAM,EAAE,GAAG1C,OAAL;AAAcsI,UAAAA,UAAU,EAAE3H;AAA1B,SAAN;AACD;AACF;;AARe,GAAX,CAAP;AAUD;;;;"}