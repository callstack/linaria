{"version":3,"sources":["../src/extract.ts"],"names":["expression","statement","generator","debug","error","evaluate","getTemplateProcessor","Module","ValueType","CollectDependencies","DetectStyledImportName","GenerateClassNames","isLazyValue","v","kind","LAZY","isNodePath","obj","node","undefined","findFreeName","scope","name","nextName","idx","hasBinding","unwrapNode","item","expressionWrapperTpl","expressionTpl","exportsLinariaPrevalTpl","addLinariaPreval","types","t","path","lazyDeps","wrapName","statements","expressions","arrayExpression","map","programNode","program","body","directives","sourceType","interpreter","extract","babel","options","process","visitor","Program","enter","state","queue","rules","index","dependencies","replacements","file","opts","filename","invalidate","traverse","ImportDeclaration","p","TaggedTemplateExpression","reduce","acc","expressionValues","values","push","filter","expressionsToEvaluate","ex","originalLazyExpressions","originalEx","length","lazyValues","code","evaluation","value","__linariaPreval","e","Error","stack","valueCache","Map","forEach","key","set","exit","_","Object","keys","metadata","linaria"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA,SAASA,UAAT,EAAqBC,SAArB,QAAsC,iBAAtC;AACA,OAAOC,SAAP,MAAsB,kBAAtB;AACA,SAASC,KAAT,EAAgBC,KAAhB,QAA6B,iBAA7B;AACA,OAAOC,QAAP,MAAqB,cAArB;AACA,OAAOC,oBAAP,MAAiC,gCAAjC;AACA,OAAOC,MAAP,MAAmB,UAAnB;AAQA,SAASC,SAAT,QAA0B,SAA1B;AACA,OAAOC,mBAAP,MAAgC,gCAAhC;AACA,OAAOC,sBAAP,MAAmC,mCAAnC;AACA,OAAOC,kBAAP,MAA+B,+BAA/B;;AAGA,SAASC,WAAT,CAAqBC,CAArB,EAAyD;AACvD,SAAOA,CAAC,CAACC,IAAF,KAAWN,SAAS,CAACO,IAA5B;AACD;;AAED,SAASC,UAAT,CAAoCC,GAApC,EAA8E;AAC5E,SAAO,UAAUA,GAAV,IAAiBA,GAAG,EAAEC,IAAL,KAAcC,SAAtC;AACD;;AAED,SAASC,YAAT,CAAsBC,KAAtB,EAAoCC,IAApC,EAA0D;AACxD;AACA,MAAIC,QAAQ,GAAGD,IAAf;AACA,MAAIE,GAAG,GAAG,CAAV;;AACA,SAAOH,KAAK,CAACI,UAAN,CAAiBF,QAAjB,EAA2B,KAA3B,CAAP,EAA0C;AACxC;AACA;AACAC,IAAAA,GAAG,IAAI,CAAP;AACAD,IAAAA,QAAQ,GAAI,QAAOC,GAAI,EAAvB;AACD;;AAED,SAAOD,QAAP;AACD;;AAED,SAASG,UAAT,CACEC,IADF,EAEc;AACZ,MAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B,WAAOA,IAAP;AACD;;AAED,SAAOX,UAAU,CAACW,IAAD,CAAV,GAAmBA,IAAI,CAACT,IAAxB,GAA+BS,IAAtC;AACD,C,CAED;;;AACA,MAAMC,oBAAoB,GAAG3B,SAAS,CAAE;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CARsC,CAAtC;AAUA,MAAM4B,aAAa,GAAG7B,UAAU,CAAE,oCAAF,CAAhC;AACA,MAAM8B,uBAAuB,GAAG7B,SAAS,CACtC,2CADsC,CAAzC;;AAIA,SAAS8B,gBAAT,CACE;AAAEC,EAAAA,KAAK,EAAEC;AAAT,CADF,EAEEC,IAFF,EAGEC,QAHF,EAIW;AACT;AACA,QAAMC,QAAQ,GAAGhB,YAAY,CAACc,IAAI,CAACb,KAAN,EAAa,OAAb,CAA7B;AACA,QAAMgB,UAAU,GAAG,CACjBT,oBAAoB,CAAC;AAAEQ,IAAAA;AAAF,GAAD,CADH,EAEjBN,uBAAuB,CAAC;AACtBQ,IAAAA,WAAW,EAAEL,CAAC,CAACM,eAAF,CACXJ,QAAQ,CAACK,GAAT,CAAcxC,UAAD,IAAgB6B,aAAa,CAAC;AAAE7B,MAAAA,UAAF;AAAcoC,MAAAA;AAAd,KAAD,CAA1C,CADW;AADS,GAAD,CAFN,CAAnB;AASA,QAAMK,WAAW,GAAGP,IAAI,CAAChB,IAAzB;AACA,SAAOe,CAAC,CAACS,OAAF,CACL,CAAC,GAAGD,WAAW,CAACE,IAAhB,EAAsB,GAAGN,UAAzB,CADK,EAELI,WAAW,CAACG,UAFP,EAGLH,WAAW,CAACI,UAHP,EAILJ,WAAW,CAACK,WAJP,CAAP;AAMD;;AAED,eAAe,SAASC,OAAT,CACbC,KADa,EAEbC,OAFa,EAGgB;AAC7B,QAAMC,OAAO,GAAG5C,oBAAoB,CAAC0C,KAAD,EAAQC,OAAR,CAApC;AAEA,SAAO;AACLE,IAAAA,OAAO,EAAE;AACPC,MAAAA,OAAO,EAAE;AACPC,QAAAA,KAAK,CAACnB,IAAD,EAA0BoB,KAA1B,EAAwC;AAC3C;AACAA,UAAAA,KAAK,CAACC,KAAN,GAAc,EAAd;AACAD,UAAAA,KAAK,CAACE,KAAN,GAAc,EAAd;AACAF,UAAAA,KAAK,CAACG,KAAN,GAAc,CAAC,CAAf;AACAH,UAAAA,KAAK,CAACI,YAAN,GAAqB,EAArB;AACAJ,UAAAA,KAAK,CAACK,YAAN,GAAqB,EAArB;AACAxD,UAAAA,KAAK,CAAC,kBAAD,EAAqBmD,KAAK,CAACM,IAAN,CAAWC,IAAX,CAAgBC,QAArC,CAAL,CAP2C,CAS3C;;AACAvD,UAAAA,MAAM,CAACwD,UAAP,GAV2C,CAY3C;AACA;;AACA7B,UAAAA,IAAI,CAAC8B,QAAL,CAAc;AACZC,YAAAA,iBAAiB,EAAGC,CAAD,IAAOxD,sBAAsB,CAACsC,KAAD,EAAQkB,CAAR,EAAWZ,KAAX,CADpC;AAEZa,YAAAA,wBAAwB,EAAGD,CAAD,IAAO;AAC/BvD,cAAAA,kBAAkB,CAACqC,KAAD,EAAQkB,CAAR,EAAWZ,KAAX,EAAkBL,OAAlB,CAAlB;AACAxC,cAAAA,mBAAmB,CAACuC,KAAD,EAAQkB,CAAR,EAAWZ,KAAX,EAAkBL,OAAlB,CAAnB;AACD;AALW,WAAd;AAQA,gBAAMd,QAAQ,GAAGmB,KAAK,CAACC,KAAN,CAAYa,MAAZ,CACf,CAACC,GAAD,EAAM;AAAEC,YAAAA,gBAAgB,EAAEC;AAApB,WAAN,KAAuC;AACrCF,YAAAA,GAAG,CAACG,IAAJ,CAAS,GAAGD,MAAM,CAACE,MAAP,CAAc7D,WAAd,CAAZ;AACA,mBAAOyD,GAAP;AACD,WAJc,EAKf,EALe,CAAjB;AAQA,gBAAMK,qBAAqB,GAAGvC,QAAQ,CAACK,GAAT,CAAc3B,CAAD,IAAOa,UAAU,CAACb,CAAC,CAAC8D,EAAH,CAA9B,CAA9B;AACA,gBAAMC,uBAAuB,GAAGzC,QAAQ,CAACK,GAAT,CAAc3B,CAAD,IAC3Ca,UAAU,CAACb,CAAC,CAACgE,UAAH,CADoB,CAAhC;AAIA1E,UAAAA,KAAK,CAAC,iBAAD,EAAoBgC,QAAQ,CAAC2C,MAA7B,CAAL;AAEA,cAAIC,UAAiB,GAAG,EAAxB;;AAEA,cAAIL,qBAAqB,CAACI,MAAtB,GAA+B,CAAnC,EAAsC;AACpC3E,YAAAA,KAAK,CACH,qCADG,EAEHyE,uBAAuB,CAACpC,GAAxB,CAA6BtB,IAAD,IAC1B,OAAOA,IAAP,KAAgB,QAAhB,GAA2BhB,SAAS,CAACgB,IAAD,CAAT,CAAgB8D,IAA3C,GAAkD9D,IADpD,CAFG,CAAL;AAMAf,YAAAA,KAAK,CACH,oCADG,EAEHuE,qBAAqB,CAAClC,GAAtB,CAA2BtB,IAAD,IACxB,OAAOA,IAAP,KAAgB,QAAhB,GAA2BhB,SAAS,CAACgB,IAAD,CAAT,CAAgB8D,IAA3C,GAAkD9D,IADpD,CAFG,CAAL;AAOA,kBAAMwB,OAAO,GAAGX,gBAAgB,CAC9BiB,KAD8B,EAE9Bd,IAF8B,EAG9BwC,qBAH8B,CAAhC;AAKA,kBAAM;AAAEM,cAAAA;AAAF,gBAAW9E,SAAS,CAACwC,OAAD,CAA1B;AACAvC,YAAAA,KAAK,CAAC,oBAAD,EAAuB,EAAvB,CAAL;;AACA,gBAAI;AACF,oBAAM8E,UAAU,GAAG5E,QAAQ,CACzB2E,IADyB,EAEzB1B,KAAK,CAACM,IAAN,CAAWC,IAAX,CAAgBC,QAFS,EAGzBb,OAHyB,CAA3B;AAKA9C,cAAAA,KAAK,CAAC,qBAAD,EAAwB8E,UAAU,CAACvB,YAAnC,CAAL;AAEAJ,cAAAA,KAAK,CAACI,YAAN,CAAmBc,IAAnB,CAAwB,GAAGS,UAAU,CAACvB,YAAtC;AACAqB,cAAAA,UAAU,GAAGE,UAAU,CAACC,KAAX,CAAiBC,eAAjB,IAAoC,EAAjD;AACAhF,cAAAA,KAAK,CAAC,kBAAD,EAAqB8E,UAAU,CAACC,KAAX,CAAiBC,eAAtC,CAAL;AACD,aAXD,CAWE,OAAOC,CAAP,EAAmB;AACnBhF,cAAAA,KAAK,CAAC,0BAAD,EAA6B4E,IAA7B,CAAL;;AACA,kBAAII,CAAC,YAAYC,KAAjB,EAAwB;AACtB,sBAAM,IAAIA,KAAJ,CACJ,4EACED,CAAC,CAACE,KADJ,GAEE,yIAFF,GAGE,gIAJE,CAAN;AAMD,eAPD,MAOO;AACL,sBAAMF,CAAN;AACD;AACF;AACF;;AAED,gBAAMG,UAAsB,GAAG,IAAIC,GAAJ,EAA/B;AACAZ,UAAAA,uBAAuB,CAACa,OAAxB,CAAgC,CAACC,GAAD,EAAMlE,GAAN,KAC9B+D,UAAU,CAACI,GAAX,CAAeD,GAAf,EAAoBX,UAAU,CAACvD,GAAD,CAA9B,CADF;AAGA8B,UAAAA,KAAK,CAACC,KAAN,CAAYkC,OAAZ,CAAqB9D,IAAD,IAAUuB,OAAO,CAACvB,IAAD,EAAO2B,KAAP,EAAciC,UAAd,CAArC;AACD,SA5FM;;AA6FPK,QAAAA,IAAI,CAACC,CAAD,EAASvC,KAAT,EAAuB;AACzB,cAAIwC,MAAM,CAACC,IAAP,CAAYzC,KAAK,CAACE,KAAlB,EAAyBsB,MAA7B,EAAqC;AACnC;AACAxB,YAAAA,KAAK,CAACM,IAAN,CAAWoC,QAAX,CAAoBC,OAApB,GAA8B;AAC5BzC,cAAAA,KAAK,EAAEF,KAAK,CAACE,KADe;AAE5BG,cAAAA,YAAY,EAAEL,KAAK,CAACK,YAFQ;AAG5BD,cAAAA,YAAY,EAAEJ,KAAK,CAACI;AAHQ,aAA9B;AAKD,WARwB,CAUzB;;;AACAnD,UAAAA,MAAM,CAACwD,UAAP;AAEA5D,UAAAA,KAAK,CAAC,gBAAD,EAAmBmD,KAAK,CAACM,IAAN,CAAWC,IAAX,CAAgBC,QAAnC,CAAL;AACD;;AA3GM;AADF;AADJ,GAAP;AAiHD","sourcesContent":["/* eslint-disable no-param-reassign */\n\n/**\n * This is an entry point for styles extraction.\n * On enter, It:\n *  - traverse the code using visitors (TaggedTemplateExpression, ImportDeclaration)\n *  - schedule evaluation of lazy dependencies (those who are not simple expressions //TODO does they have it's name?)\n *  - let templateProcessor to save evaluated values in babel state as `replacements`.\n * On exit, It:\n *  - store result of extraction in babel's file metadata\n */\n\nimport type { Node, Program, Expression } from '@babel/types';\nimport type { NodePath, Scope, Visitor } from '@babel/traverse';\nimport { expression, statement } from '@babel/template';\nimport generator from '@babel/generator';\nimport { debug, error } from '@linaria/logger';\nimport evaluate from './evaluators';\nimport getTemplateProcessor from './evaluators/templateProcessor';\nimport Module from './module';\nimport type {\n  State,\n  StrictOptions,\n  LazyValue,\n  ExpressionValue,\n  ValueCache,\n} from './types';\nimport { ValueType } from './types';\nimport CollectDependencies from './visitors/CollectDependencies';\nimport DetectStyledImportName from './visitors/DetectStyledImportName';\nimport GenerateClassNames from './visitors/GenerateClassNames';\nimport type { Core } from './babel';\n\nfunction isLazyValue(v: ExpressionValue): v is LazyValue {\n  return v.kind === ValueType.LAZY;\n}\n\nfunction isNodePath<T extends Node>(obj: NodePath<T> | T): obj is NodePath<T> {\n  return 'node' in obj && obj?.node !== undefined;\n}\n\nfunction findFreeName(scope: Scope, name: string): string {\n  // By default `name` is used as a name of the function …\n  let nextName = name;\n  let idx = 0;\n  while (scope.hasBinding(nextName, false)) {\n    // … but if there is an already defined variable with this name …\n    // … we are trying to use a name like wrap_N\n    idx += 1;\n    nextName = `wrap_${idx}`;\n  }\n\n  return nextName;\n}\n\nfunction unwrapNode<T extends Node>(\n  item: NodePath<T> | T | string\n): T | string {\n  if (typeof item === 'string') {\n    return item;\n  }\n\n  return isNodePath(item) ? item.node : item;\n}\n\n// All exported values will be wrapped with this function\nconst expressionWrapperTpl = statement(`\n  const %%wrapName%% = (fn) => {\n    try {\n      return fn();\n    } catch (e) {\n      return e;\n    }\n  };\n`);\n\nconst expressionTpl = expression(`%%wrapName%%(() => %%expression%%)`);\nconst exportsLinariaPrevalTpl = statement(\n  `exports.__linariaPreval = %%expressions%%`\n);\n\nfunction addLinariaPreval(\n  { types: t }: Core,\n  path: NodePath<Program>,\n  lazyDeps: Array<Expression | string>\n): Program {\n  // Constant __linariaPreval with all dependencies\n  const wrapName = findFreeName(path.scope, '_wrap');\n  const statements = [\n    expressionWrapperTpl({ wrapName }),\n    exportsLinariaPrevalTpl({\n      expressions: t.arrayExpression(\n        lazyDeps.map((expression) => expressionTpl({ expression, wrapName }))\n      ),\n    }),\n  ];\n\n  const programNode = path.node;\n  return t.program(\n    [...programNode.body, ...statements],\n    programNode.directives,\n    programNode.sourceType,\n    programNode.interpreter\n  );\n}\n\nexport default function extract(\n  babel: Core,\n  options: StrictOptions\n): { visitor: Visitor<State> } {\n  const process = getTemplateProcessor(babel, options);\n\n  return {\n    visitor: {\n      Program: {\n        enter(path: NodePath<Program>, state: State) {\n          // Collect all the style rules from the styles we encounter\n          state.queue = [];\n          state.rules = {};\n          state.index = -1;\n          state.dependencies = [];\n          state.replacements = [];\n          debug('extraction:start', state.file.opts.filename);\n\n          // Invalidate cache for module evaluation to get fresh modules\n          Module.invalidate();\n\n          // We need our transforms to run before anything else\n          // So we traverse here instead of a in a visitor\n          path.traverse({\n            ImportDeclaration: (p) => DetectStyledImportName(babel, p, state),\n            TaggedTemplateExpression: (p) => {\n              GenerateClassNames(babel, p, state, options);\n              CollectDependencies(babel, p, state, options);\n            },\n          });\n\n          const lazyDeps = state.queue.reduce(\n            (acc, { expressionValues: values }) => {\n              acc.push(...values.filter(isLazyValue));\n              return acc;\n            },\n            [] as LazyValue[]\n          );\n\n          const expressionsToEvaluate = lazyDeps.map((v) => unwrapNode(v.ex));\n          const originalLazyExpressions = lazyDeps.map((v) =>\n            unwrapNode(v.originalEx)\n          );\n\n          debug('lazy-deps:count', lazyDeps.length);\n\n          let lazyValues: any[] = [];\n\n          if (expressionsToEvaluate.length > 0) {\n            debug(\n              'lazy-deps:original-expressions-list',\n              originalLazyExpressions.map((node) =>\n                typeof node !== 'string' ? generator(node).code : node\n              )\n            );\n            debug(\n              'lazy-deps:expressions-to-eval-list',\n              expressionsToEvaluate.map((node) =>\n                typeof node !== 'string' ? generator(node).code : node\n              )\n            );\n\n            const program = addLinariaPreval(\n              babel,\n              path,\n              expressionsToEvaluate\n            );\n            const { code } = generator(program);\n            debug('lazy-deps:evaluate', '');\n            try {\n              const evaluation = evaluate(\n                code,\n                state.file.opts.filename,\n                options\n              );\n              debug('lazy-deps:sub-files', evaluation.dependencies);\n\n              state.dependencies.push(...evaluation.dependencies);\n              lazyValues = evaluation.value.__linariaPreval || [];\n              debug('lazy-deps:values', evaluation.value.__linariaPreval);\n            } catch (e: unknown) {\n              error('lazy-deps:evaluate:error', code);\n              if (e instanceof Error) {\n                throw new Error(\n                  'An unexpected runtime error occurred during dependencies evaluation: \\n' +\n                    e.stack +\n                    '\\n\\nIt may happen when your code or third party module is invalid or uses identifiers not available in Node environment, eg. window. \\n' +\n                    'Note that line numbers in above stack trace will most likely not match, because Linaria needed to transform your code a bit.\\n'\n                );\n              } else {\n                throw e;\n              }\n            }\n          }\n\n          const valueCache: ValueCache = new Map();\n          originalLazyExpressions.forEach((key, idx) =>\n            valueCache.set(key, lazyValues[idx])\n          );\n          state.queue.forEach((item) => process(item, state, valueCache));\n        },\n        exit(_: any, state: State) {\n          if (Object.keys(state.rules).length) {\n            // Store the result as the file metadata under linaria key\n            state.file.metadata.linaria = {\n              rules: state.rules,\n              replacements: state.replacements,\n              dependencies: state.dependencies,\n            };\n          }\n\n          // Invalidate cache for module evaluation when we're done\n          Module.invalidate();\n\n          debug('extraction:end', state.file.opts.filename);\n        },\n      },\n    },\n  };\n}\n"],"file":"extract.js"}