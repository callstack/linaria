import hasImport from './hasImport';
const cache = new WeakMap();
export default function getTemplateType({
  types: t
}, path, state, libResolver) {
  if (!cache.has(path)) {
    const {
      tag
    } = path.node;
    const localName = state.file.metadata.localName || 'styled';

    if (t.isCallExpression(tag) && t.isIdentifier(tag.callee) && tag.arguments.length === 1 && tag.callee.name === localName && hasImport(t, path.scope, state.file.opts.filename, localName, ['@linaria/react', 'linaria/react'], libResolver)) {
      const tagPath = path.get('tag');
      cache.set(path, {
        component: tagPath.get('arguments')[0]
      });
    } else if (t.isMemberExpression(tag) && t.isIdentifier(tag.object) && t.isIdentifier(tag.property) && tag.object.name === localName && hasImport(t, path.scope, state.file.opts.filename, localName, ['@linaria/react', 'linaria/react'], libResolver)) {
      cache.set(path, {
        component: {
          node: t.stringLiteral(tag.property.name)
        }
      });
    } else if (hasImport(t, path.scope, state.file.opts.filename, 'css', ['@linaria/core', 'linaria'], libResolver) && t.isIdentifier(tag) && tag.name === 'css') {
      cache.set(path, 'css');
    } else if (hasImport(t, path.scope, state.file.opts.filename, 'css', ['@linaria/atomic'], libResolver) && t.isIdentifier(tag) && tag.name === 'css') {
      cache.set(path, 'atomic-css');
    } else {
      cache.set(path, null);
    }
  }

  return cache.get(path) ?? null;
}
//# sourceMappingURL=getTemplateType.js.map