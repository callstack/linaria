{"version":3,"sources":["../src/Visitors.ts"],"names":["visitors","Identifier","node","parent","parentKey","listIdx","handler","identifierHandlers","type","kindOfDeclaration","meta","get","scope","declare","declaration","addReference","graph","addEdge","context","name","core","isKeyOfVisitors","getVisitors","aliases","t","ALIAS_KEYS","aliasVisitors","map","filter","i","v"],"mappings":";;;;;;;;AAAA;;AAEA;;AACA;;AAGA;;AAGA;;;;AAEA,MAAMA,QAAkB,GAAG;AACzBC,EAAAA,UAAU,CAERC,IAFQ,EAGRC,MAHQ,EAIRC,SAJQ,EAKRC,OAAsB,GAAG,IALjB,EAMR;AACA,QAAI,CAACF,MAAD,IAAW,CAACC,SAAhB,EAA2B;AACzB;AACD;;AAED,UAAME,OAAO,GAAGC,4BAAoB,GAAEJ,MAAM,CAACK,IAAK,IAAGJ,SAAU,EAA/C,CAAhB;;AAEA,QAAI,OAAOE,OAAP,KAAmB,UAAvB,EAAmC;AACjCA,MAAAA,OAAO,CAAC,IAAD,EAAOJ,IAAP,EAAaC,MAAb,EAAqBC,SAArB,EAAgCC,OAAhC,CAAP;AACA;AACD;;AAED,QAAIC,OAAO,KAAK,MAAhB,EAAwB;AACtB;AACD;;AAED,QAAIA,OAAO,KAAK,SAAhB,EAA2B;AACzB,YAAMG,iBAAiB,GAAG,KAAKC,IAAL,CAAUC,GAAV,CAAc,qBAAd,CAA1B;AACA,WAAKC,KAAL,CAAWC,OAAX,CAAmBX,IAAnB,EAAyBO,iBAAiB,KAAK,KAA/C,EAAsD,IAAtD;AACA;AACD;;AAED,QAAIH,OAAO,KAAK,OAAhB,EAAyB;AACvB,YAAMQ,WAAW,GAAG,KAAKF,KAAL,CAAWG,YAAX,CAAwBb,IAAxB,CAApB,CADuB,CAEvB;;AACA,UAAIY,WAAJ,EAAiB;AACf;AACA,aAAKE,KAAL,CAAWC,OAAX,CAAmBf,IAAnB,EAAyBY,WAAzB;AAEA,cAAMI,OAAO,GAAG,uBAAK,KAAKA,OAAV,CAAhB;;AACA,YAAIA,OAAO,KAAK,MAAhB,EAAwB;AACtB;AACA,eAAKF,KAAL,CAAWC,OAAX,CAAmBH,WAAnB,EAAgCZ,IAAhC;AACD;AACF;;AAED;AACD;AAED;AACJ;AACA;AACA;;;AACI,sBACE,kBADF,EAEE,sBAFF,EAGEA,IAAI,CAACiB,IAHP,EAIEhB,MAAM,CAACK,IAJT,EAKEJ,SALF,EAMEC,OANF;AAQD,GA1DwB;;AA4DzB,KAAGe;AA5DsB,CAA3B;;AA+DA,MAAMC,eAAe,GAAIb,IAAD,IACtBA,IAAI,IAAIR,QADV;;AAGO,SAASsB,WAAT,CAAyCpB,IAAzC,EAAwE;AAC7E,QAAMqB,OAAO,GAAGC,YAAEC,UAAF,CAAavB,IAAI,CAACM,IAAlB,KAA2B,EAA3C;AACA,QAAMkB,aAAa,GAAGH,OAAO,CAC1BI,GADmB,CACdnB,IAAD,IAAWa,eAAe,CAACb,IAAD,CAAf,GAAwBR,QAAQ,CAACQ,IAAD,CAAhC,GAAyC,IADrC,EAEnBoB,MAFmB,CAEXC,CAAD,IAAOA,CAFK,CAAtB;AAGA,SAAO,CAAC,GAAGH,aAAJ,EAAmB1B,QAAQ,CAACE,IAAI,CAACM,IAAN,CAA3B,EAA0DoB,MAA1D,CACJE,CAAD,IAAOA,CADF,CAAP;AAGD;;eAEc9B,Q","sourcesContent":["import { types as t } from '@babel/core';\nimport type { Identifier, Node } from '@babel/types';\nimport { warn } from '@linaria/logger';\nimport { peek } from '@linaria/babel-preset';\nimport type { VisitorKeys } from '@linaria/babel-preset';\nimport GraphBuilderState from './GraphBuilderState';\nimport identifierHandlers from './identifierHandlers';\nimport type { Visitor, Visitors } from './types';\n\nimport { visitors as core } from './langs/core';\n\nconst visitors: Visitors = {\n  Identifier<TParent extends Node>(\n    this: GraphBuilderState,\n    node: Identifier,\n    parent: TParent | null,\n    parentKey: VisitorKeys<TParent> | null,\n    listIdx: number | null = null\n  ) {\n    if (!parent || !parentKey) {\n      return;\n    }\n\n    const handler = identifierHandlers[`${parent.type}:${parentKey}`];\n\n    if (typeof handler === 'function') {\n      handler(this, node, parent, parentKey, listIdx);\n      return;\n    }\n\n    if (handler === 'keep') {\n      return;\n    }\n\n    if (handler === 'declare') {\n      const kindOfDeclaration = this.meta.get('kind-of-declaration');\n      this.scope.declare(node, kindOfDeclaration === 'var', null);\n      return;\n    }\n\n    if (handler === 'refer') {\n      const declaration = this.scope.addReference(node);\n      // Let's check that it's not a global variable\n      if (declaration) {\n        // usage of a variable depends on its declaration\n        this.graph.addEdge(node, declaration);\n\n        const context = peek(this.context);\n        if (context === 'lval') {\n          // This is an identifier in the left side of an assignment expression and a variable value depends on that.\n          this.graph.addEdge(declaration, node);\n        }\n      }\n\n      return;\n    }\n\n    /*\n     * There is an unhandled identifier.\n     * This case should be added to ./identifierHandlers.ts\n     */\n    warn(\n      'evaluator:shaker',\n      'Unhandled identifier',\n      node.name,\n      parent.type,\n      parentKey,\n      listIdx\n    );\n  },\n\n  ...core,\n};\n\nconst isKeyOfVisitors = (type: string): type is keyof Visitors =>\n  type in visitors;\n\nexport function getVisitors<TNode extends Node>(node: TNode): Visitor<TNode>[] {\n  const aliases = t.ALIAS_KEYS[node.type] || [];\n  const aliasVisitors = aliases\n    .map((type) => (isKeyOfVisitors(type) ? visitors[type] : null))\n    .filter((i) => i) as Visitor<TNode>[];\n  return [...aliasVisitors, visitors[node.type] as Visitor<TNode>].filter(\n    (v) => v\n  );\n}\n\nexport default visitors;\n"],"file":"Visitors.js"}